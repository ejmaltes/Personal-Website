{"ast":null,"code":"/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactUpdates\n */\n\"use strict\";\n\nvar CallbackQueue = require(\"./CallbackQueue\");\n\nvar PooledClass = require(\"./PooledClass\");\n\nvar ReactCurrentOwner = require(\"./ReactCurrentOwner\");\n\nvar ReactPerf = require(\"./ReactPerf\");\n\nvar Transaction = require(\"./Transaction\");\n\nvar assign = require(\"./Object.assign\");\n\nvar invariant = require(\"./invariant\");\n\nvar warning = require(\"./warning\");\n\nvar dirtyComponents = [];\nvar asapCallbackQueue = CallbackQueue.getPooled();\nvar asapEnqueued = false;\nvar batchingStrategy = null;\n\nfunction ensureInjected() {\n  \"production\" !== process.env.NODE_ENV ? invariant(ReactUpdates.ReactReconcileTransaction && batchingStrategy, 'ReactUpdates: must inject a reconcile transaction class and batching ' + 'strategy') : invariant(ReactUpdates.ReactReconcileTransaction && batchingStrategy);\n}\n\nvar NESTED_UPDATES = {\n  initialize: function () {\n    this.dirtyComponentsLength = dirtyComponents.length;\n  },\n  close: function () {\n    if (this.dirtyComponentsLength !== dirtyComponents.length) {\n      // Additional updates were enqueued by componentDidUpdate handlers or\n      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run\n      // these new updates so that if A's componentDidUpdate calls setState on\n      // B, B will update before the callback A's updater provided when calling\n      // setState.\n      dirtyComponents.splice(0, this.dirtyComponentsLength);\n      flushBatchedUpdates();\n    } else {\n      dirtyComponents.length = 0;\n    }\n  }\n};\nvar UPDATE_QUEUEING = {\n  initialize: function () {\n    this.callbackQueue.reset();\n  },\n  close: function () {\n    this.callbackQueue.notifyAll();\n  }\n};\nvar TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];\n\nfunction ReactUpdatesFlushTransaction() {\n  this.reinitializeTransaction();\n  this.dirtyComponentsLength = null;\n  this.callbackQueue = CallbackQueue.getPooled();\n  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled();\n}\n\nassign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {\n  getTransactionWrappers: function () {\n    return TRANSACTION_WRAPPERS;\n  },\n  destructor: function () {\n    this.dirtyComponentsLength = null;\n    CallbackQueue.release(this.callbackQueue);\n    this.callbackQueue = null;\n    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);\n    this.reconcileTransaction = null;\n  },\n  perform: function (method, scope, a) {\n    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`\n    // with this transaction's wrappers around it.\n    return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);\n  }\n});\nPooledClass.addPoolingTo(ReactUpdatesFlushTransaction);\n\nfunction batchedUpdates(callback, a, b) {\n  ensureInjected();\n  batchingStrategy.batchedUpdates(callback, a, b);\n}\n/**\n * Array comparator for ReactComponents by owner depth\n *\n * @param {ReactComponent} c1 first component you're comparing\n * @param {ReactComponent} c2 second component you're comparing\n * @return {number} Return value usable by Array.prototype.sort().\n */\n\n\nfunction mountDepthComparator(c1, c2) {\n  return c1._mountDepth - c2._mountDepth;\n}\n\nfunction runBatchedUpdates(transaction) {\n  var len = transaction.dirtyComponentsLength;\n  \"production\" !== process.env.NODE_ENV ? invariant(len === dirtyComponents.length, 'Expected flush transaction\\'s stored dirty-components length (%s) to ' + 'match dirty-components array length (%s).', len, dirtyComponents.length) : invariant(len === dirtyComponents.length); // Since reconciling a component higher in the owner hierarchy usually (not\n  // always -- see shouldComponentUpdate()) will reconcile children, reconcile\n  // them before their children by sorting the array.\n\n  dirtyComponents.sort(mountDepthComparator);\n\n  for (var i = 0; i < len; i++) {\n    // If a component is unmounted before pending changes apply, ignore them\n    // TODO: Queue unmounts in the same list to avoid this happening at all\n    var component = dirtyComponents[i];\n\n    if (component.isMounted()) {\n      // If performUpdateIfNecessary happens to enqueue any new updates, we\n      // shouldn't execute the callbacks until the next render happens, so\n      // stash the callbacks first\n      var callbacks = component._pendingCallbacks;\n      component._pendingCallbacks = null;\n      component.performUpdateIfNecessary(transaction.reconcileTransaction);\n\n      if (callbacks) {\n        for (var j = 0; j < callbacks.length; j++) {\n          transaction.callbackQueue.enqueue(callbacks[j], component);\n        }\n      }\n    }\n  }\n}\n\nvar flushBatchedUpdates = ReactPerf.measure('ReactUpdates', 'flushBatchedUpdates', function () {\n  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents\n  // array and perform any updates enqueued by mount-ready handlers (i.e.,\n  // componentDidUpdate) but we need to check here too in order to catch\n  // updates enqueued by setState callbacks and asap calls.\n  while (dirtyComponents.length || asapEnqueued) {\n    if (dirtyComponents.length) {\n      var transaction = ReactUpdatesFlushTransaction.getPooled();\n      transaction.perform(runBatchedUpdates, null, transaction);\n      ReactUpdatesFlushTransaction.release(transaction);\n    }\n\n    if (asapEnqueued) {\n      asapEnqueued = false;\n      var queue = asapCallbackQueue;\n      asapCallbackQueue = CallbackQueue.getPooled();\n      queue.notifyAll();\n      CallbackQueue.release(queue);\n    }\n  }\n});\n/**\n * Mark a component as needing a rerender, adding an optional callback to a\n * list of functions which will be executed once the rerender occurs.\n */\n\nfunction enqueueUpdate(component, callback) {\n  \"production\" !== process.env.NODE_ENV ? invariant(!callback || typeof callback === \"function\", 'enqueueUpdate(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\\'t callable.') : invariant(!callback || typeof callback === \"function\");\n  ensureInjected(); // Various parts of our code (such as ReactCompositeComponent's\n  // _renderValidatedComponent) assume that calls to render aren't nested;\n  // verify that that's the case. (This is called by each top-level update\n  // function, like setProps, setState, forceUpdate, etc.; creation and\n  // destruction of top-level components is guarded in ReactMount.)\n\n  \"production\" !== process.env.NODE_ENV ? warning(ReactCurrentOwner.current == null, 'enqueueUpdate(): Render methods should be a pure function of props ' + 'and state; triggering nested component updates from render is not ' + 'allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate.') : null;\n\n  if (!batchingStrategy.isBatchingUpdates) {\n    batchingStrategy.batchedUpdates(enqueueUpdate, component, callback);\n    return;\n  }\n\n  dirtyComponents.push(component);\n\n  if (callback) {\n    if (component._pendingCallbacks) {\n      component._pendingCallbacks.push(callback);\n    } else {\n      component._pendingCallbacks = [callback];\n    }\n  }\n}\n/**\n * Enqueue a callback to be run at the end of the current batching cycle. Throws\n * if no updates are currently being performed.\n */\n\n\nfunction asap(callback, context) {\n  \"production\" !== process.env.NODE_ENV ? invariant(batchingStrategy.isBatchingUpdates, 'ReactUpdates.asap: Can\\'t enqueue an asap callback in a context where' + 'updates are not being batched.') : invariant(batchingStrategy.isBatchingUpdates);\n  asapCallbackQueue.enqueue(callback, context);\n  asapEnqueued = true;\n}\n\nvar ReactUpdatesInjection = {\n  injectReconcileTransaction: function (ReconcileTransaction) {\n    \"production\" !== process.env.NODE_ENV ? invariant(ReconcileTransaction, 'ReactUpdates: must provide a reconcile transaction class') : invariant(ReconcileTransaction);\n    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;\n  },\n  injectBatchingStrategy: function (_batchingStrategy) {\n    \"production\" !== process.env.NODE_ENV ? invariant(_batchingStrategy, 'ReactUpdates: must provide a batching strategy') : invariant(_batchingStrategy);\n    \"production\" !== process.env.NODE_ENV ? invariant(typeof _batchingStrategy.batchedUpdates === 'function', 'ReactUpdates: must provide a batchedUpdates() function') : invariant(typeof _batchingStrategy.batchedUpdates === 'function');\n    \"production\" !== process.env.NODE_ENV ? invariant(typeof _batchingStrategy.isBatchingUpdates === 'boolean', 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : invariant(typeof _batchingStrategy.isBatchingUpdates === 'boolean');\n    batchingStrategy = _batchingStrategy;\n  }\n};\nvar ReactUpdates = {\n  /**\n   * React references `ReactReconcileTransaction` using this property in order\n   * to allow dependency injection.\n   *\n   * @internal\n   */\n  ReactReconcileTransaction: null,\n  batchedUpdates: batchedUpdates,\n  enqueueUpdate: enqueueUpdate,\n  flushBatchedUpdates: flushBatchedUpdates,\n  injection: ReactUpdatesInjection,\n  asap: asap\n};\nmodule.exports = ReactUpdates;","map":{"version":3,"sources":["/Users/ejmaltes/Desktop/Personal-Website/node_modules/react-object-fit-cover/node_modules/react/lib/ReactUpdates.js"],"names":["CallbackQueue","require","PooledClass","ReactCurrentOwner","ReactPerf","Transaction","assign","invariant","warning","dirtyComponents","asapCallbackQueue","getPooled","asapEnqueued","batchingStrategy","ensureInjected","process","env","NODE_ENV","ReactUpdates","ReactReconcileTransaction","NESTED_UPDATES","initialize","dirtyComponentsLength","length","close","splice","flushBatchedUpdates","UPDATE_QUEUEING","callbackQueue","reset","notifyAll","TRANSACTION_WRAPPERS","ReactUpdatesFlushTransaction","reinitializeTransaction","reconcileTransaction","prototype","Mixin","getTransactionWrappers","destructor","release","perform","method","scope","a","call","addPoolingTo","batchedUpdates","callback","b","mountDepthComparator","c1","c2","_mountDepth","runBatchedUpdates","transaction","len","sort","i","component","isMounted","callbacks","_pendingCallbacks","performUpdateIfNecessary","j","enqueue","measure","queue","enqueueUpdate","current","isBatchingUpdates","push","asap","context","ReactUpdatesInjection","injectReconcileTransaction","ReconcileTransaction","injectBatchingStrategy","_batchingStrategy","injection","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactUpdates\n */\n\n\"use strict\";\n\nvar CallbackQueue = require(\"./CallbackQueue\");\nvar PooledClass = require(\"./PooledClass\");\nvar ReactCurrentOwner = require(\"./ReactCurrentOwner\");\nvar ReactPerf = require(\"./ReactPerf\");\nvar Transaction = require(\"./Transaction\");\n\nvar assign = require(\"./Object.assign\");\nvar invariant = require(\"./invariant\");\nvar warning = require(\"./warning\");\n\nvar dirtyComponents = [];\nvar asapCallbackQueue = CallbackQueue.getPooled();\nvar asapEnqueued = false;\n\nvar batchingStrategy = null;\n\nfunction ensureInjected() {\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    ReactUpdates.ReactReconcileTransaction && batchingStrategy,\n    'ReactUpdates: must inject a reconcile transaction class and batching ' +\n    'strategy'\n  ) : invariant(ReactUpdates.ReactReconcileTransaction && batchingStrategy));\n}\n\nvar NESTED_UPDATES = {\n  initialize: function() {\n    this.dirtyComponentsLength = dirtyComponents.length;\n  },\n  close: function() {\n    if (this.dirtyComponentsLength !== dirtyComponents.length) {\n      // Additional updates were enqueued by componentDidUpdate handlers or\n      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run\n      // these new updates so that if A's componentDidUpdate calls setState on\n      // B, B will update before the callback A's updater provided when calling\n      // setState.\n      dirtyComponents.splice(0, this.dirtyComponentsLength);\n      flushBatchedUpdates();\n    } else {\n      dirtyComponents.length = 0;\n    }\n  }\n};\n\nvar UPDATE_QUEUEING = {\n  initialize: function() {\n    this.callbackQueue.reset();\n  },\n  close: function() {\n    this.callbackQueue.notifyAll();\n  }\n};\n\nvar TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];\n\nfunction ReactUpdatesFlushTransaction() {\n  this.reinitializeTransaction();\n  this.dirtyComponentsLength = null;\n  this.callbackQueue = CallbackQueue.getPooled();\n  this.reconcileTransaction =\n    ReactUpdates.ReactReconcileTransaction.getPooled();\n}\n\nassign(\n  ReactUpdatesFlushTransaction.prototype,\n  Transaction.Mixin, {\n  getTransactionWrappers: function() {\n    return TRANSACTION_WRAPPERS;\n  },\n\n  destructor: function() {\n    this.dirtyComponentsLength = null;\n    CallbackQueue.release(this.callbackQueue);\n    this.callbackQueue = null;\n    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);\n    this.reconcileTransaction = null;\n  },\n\n  perform: function(method, scope, a) {\n    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`\n    // with this transaction's wrappers around it.\n    return Transaction.Mixin.perform.call(\n      this,\n      this.reconcileTransaction.perform,\n      this.reconcileTransaction,\n      method,\n      scope,\n      a\n    );\n  }\n});\n\nPooledClass.addPoolingTo(ReactUpdatesFlushTransaction);\n\nfunction batchedUpdates(callback, a, b) {\n  ensureInjected();\n  batchingStrategy.batchedUpdates(callback, a, b);\n}\n\n/**\n * Array comparator for ReactComponents by owner depth\n *\n * @param {ReactComponent} c1 first component you're comparing\n * @param {ReactComponent} c2 second component you're comparing\n * @return {number} Return value usable by Array.prototype.sort().\n */\nfunction mountDepthComparator(c1, c2) {\n  return c1._mountDepth - c2._mountDepth;\n}\n\nfunction runBatchedUpdates(transaction) {\n  var len = transaction.dirtyComponentsLength;\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    len === dirtyComponents.length,\n    'Expected flush transaction\\'s stored dirty-components length (%s) to ' +\n    'match dirty-components array length (%s).',\n    len,\n    dirtyComponents.length\n  ) : invariant(len === dirtyComponents.length));\n\n  // Since reconciling a component higher in the owner hierarchy usually (not\n  // always -- see shouldComponentUpdate()) will reconcile children, reconcile\n  // them before their children by sorting the array.\n  dirtyComponents.sort(mountDepthComparator);\n\n  for (var i = 0; i < len; i++) {\n    // If a component is unmounted before pending changes apply, ignore them\n    // TODO: Queue unmounts in the same list to avoid this happening at all\n    var component = dirtyComponents[i];\n    if (component.isMounted()) {\n      // If performUpdateIfNecessary happens to enqueue any new updates, we\n      // shouldn't execute the callbacks until the next render happens, so\n      // stash the callbacks first\n      var callbacks = component._pendingCallbacks;\n      component._pendingCallbacks = null;\n      component.performUpdateIfNecessary(transaction.reconcileTransaction);\n\n      if (callbacks) {\n        for (var j = 0; j < callbacks.length; j++) {\n          transaction.callbackQueue.enqueue(\n            callbacks[j],\n            component\n          );\n        }\n      }\n    }\n  }\n}\n\nvar flushBatchedUpdates = ReactPerf.measure(\n  'ReactUpdates',\n  'flushBatchedUpdates',\n  function() {\n    // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents\n    // array and perform any updates enqueued by mount-ready handlers (i.e.,\n    // componentDidUpdate) but we need to check here too in order to catch\n    // updates enqueued by setState callbacks and asap calls.\n    while (dirtyComponents.length || asapEnqueued) {\n      if (dirtyComponents.length) {\n        var transaction = ReactUpdatesFlushTransaction.getPooled();\n        transaction.perform(runBatchedUpdates, null, transaction);\n        ReactUpdatesFlushTransaction.release(transaction);\n      }\n\n      if (asapEnqueued) {\n        asapEnqueued = false;\n        var queue = asapCallbackQueue;\n        asapCallbackQueue = CallbackQueue.getPooled();\n        queue.notifyAll();\n        CallbackQueue.release(queue);\n      }\n    }\n  }\n);\n\n/**\n * Mark a component as needing a rerender, adding an optional callback to a\n * list of functions which will be executed once the rerender occurs.\n */\nfunction enqueueUpdate(component, callback) {\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    !callback || typeof callback === \"function\",\n    'enqueueUpdate(...): You called `setProps`, `replaceProps`, ' +\n    '`setState`, `replaceState`, or `forceUpdate` with a callback that ' +\n    'isn\\'t callable.'\n  ) : invariant(!callback || typeof callback === \"function\"));\n  ensureInjected();\n\n  // Various parts of our code (such as ReactCompositeComponent's\n  // _renderValidatedComponent) assume that calls to render aren't nested;\n  // verify that that's the case. (This is called by each top-level update\n  // function, like setProps, setState, forceUpdate, etc.; creation and\n  // destruction of top-level components is guarded in ReactMount.)\n  (\"production\" !== process.env.NODE_ENV ? warning(\n    ReactCurrentOwner.current == null,\n    'enqueueUpdate(): Render methods should be a pure function of props ' +\n    'and state; triggering nested component updates from render is not ' +\n    'allowed. If necessary, trigger nested updates in ' +\n    'componentDidUpdate.'\n  ) : null);\n\n  if (!batchingStrategy.isBatchingUpdates) {\n    batchingStrategy.batchedUpdates(enqueueUpdate, component, callback);\n    return;\n  }\n\n  dirtyComponents.push(component);\n\n  if (callback) {\n    if (component._pendingCallbacks) {\n      component._pendingCallbacks.push(callback);\n    } else {\n      component._pendingCallbacks = [callback];\n    }\n  }\n}\n\n/**\n * Enqueue a callback to be run at the end of the current batching cycle. Throws\n * if no updates are currently being performed.\n */\nfunction asap(callback, context) {\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    batchingStrategy.isBatchingUpdates,\n    'ReactUpdates.asap: Can\\'t enqueue an asap callback in a context where' +\n    'updates are not being batched.'\n  ) : invariant(batchingStrategy.isBatchingUpdates));\n  asapCallbackQueue.enqueue(callback, context);\n  asapEnqueued = true;\n}\n\nvar ReactUpdatesInjection = {\n  injectReconcileTransaction: function(ReconcileTransaction) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      ReconcileTransaction,\n      'ReactUpdates: must provide a reconcile transaction class'\n    ) : invariant(ReconcileTransaction));\n    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;\n  },\n\n  injectBatchingStrategy: function(_batchingStrategy) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      _batchingStrategy,\n      'ReactUpdates: must provide a batching strategy'\n    ) : invariant(_batchingStrategy));\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      typeof _batchingStrategy.batchedUpdates === 'function',\n      'ReactUpdates: must provide a batchedUpdates() function'\n    ) : invariant(typeof _batchingStrategy.batchedUpdates === 'function'));\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      typeof _batchingStrategy.isBatchingUpdates === 'boolean',\n      'ReactUpdates: must provide an isBatchingUpdates boolean attribute'\n    ) : invariant(typeof _batchingStrategy.isBatchingUpdates === 'boolean'));\n    batchingStrategy = _batchingStrategy;\n  }\n};\n\nvar ReactUpdates = {\n  /**\n   * React references `ReactReconcileTransaction` using this property in order\n   * to allow dependency injection.\n   *\n   * @internal\n   */\n  ReactReconcileTransaction: null,\n\n  batchedUpdates: batchedUpdates,\n  enqueueUpdate: enqueueUpdate,\n  flushBatchedUpdates: flushBatchedUpdates,\n  injection: ReactUpdatesInjection,\n  asap: asap\n};\n\nmodule.exports = ReactUpdates;\n"]},"metadata":{},"sourceType":"script"}