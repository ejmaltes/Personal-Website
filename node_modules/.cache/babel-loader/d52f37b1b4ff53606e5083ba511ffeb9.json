{"ast":null,"code":"/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactPropTransferer\n */\n\"use strict\";\n\nvar assign = require(\"./Object.assign\");\n\nvar emptyFunction = require(\"./emptyFunction\");\n\nvar invariant = require(\"./invariant\");\n\nvar joinClasses = require(\"./joinClasses\");\n\nvar warning = require(\"./warning\");\n\nvar didWarn = false;\n/**\n * Creates a transfer strategy that will merge prop values using the supplied\n * `mergeStrategy`. If a prop was previously unset, this just sets it.\n *\n * @param {function} mergeStrategy\n * @return {function}\n */\n\nfunction createTransferStrategy(mergeStrategy) {\n  return function (props, key, value) {\n    if (!props.hasOwnProperty(key)) {\n      props[key] = value;\n    } else {\n      props[key] = mergeStrategy(props[key], value);\n    }\n  };\n}\n\nvar transferStrategyMerge = createTransferStrategy(function (a, b) {\n  // `merge` overrides the first object's (`props[key]` above) keys using the\n  // second object's (`value`) keys. An object's style's existing `propA` would\n  // get overridden. Flip the order here.\n  return assign({}, b, a);\n});\n/**\n * Transfer strategies dictate how props are transferred by `transferPropsTo`.\n * NOTE: if you add any more exceptions to this list you should be sure to\n * update `cloneWithProps()` accordingly.\n */\n\nvar TransferStrategies = {\n  /**\n   * Never transfer `children`.\n   */\n  children: emptyFunction,\n\n  /**\n   * Transfer the `className` prop by merging them.\n   */\n  className: createTransferStrategy(joinClasses),\n\n  /**\n   * Transfer the `style` prop (which is an object) by merging them.\n   */\n  style: transferStrategyMerge\n};\n/**\n * Mutates the first argument by transferring the properties from the second\n * argument.\n *\n * @param {object} props\n * @param {object} newProps\n * @return {object}\n */\n\nfunction transferInto(props, newProps) {\n  for (var thisKey in newProps) {\n    if (!newProps.hasOwnProperty(thisKey)) {\n      continue;\n    }\n\n    var transferStrategy = TransferStrategies[thisKey];\n\n    if (transferStrategy && TransferStrategies.hasOwnProperty(thisKey)) {\n      transferStrategy(props, thisKey, newProps[thisKey]);\n    } else if (!props.hasOwnProperty(thisKey)) {\n      props[thisKey] = newProps[thisKey];\n    }\n  }\n\n  return props;\n}\n/**\n * ReactPropTransferer are capable of transferring props to another component\n * using a `transferPropsTo` method.\n *\n * @class ReactPropTransferer\n */\n\n\nvar ReactPropTransferer = {\n  TransferStrategies: TransferStrategies,\n\n  /**\n   * Merge two props objects using TransferStrategies.\n   *\n   * @param {object} oldProps original props (they take precedence)\n   * @param {object} newProps new props to merge in\n   * @return {object} a new object containing both sets of props merged.\n   */\n  mergeProps: function (oldProps, newProps) {\n    return transferInto(assign({}, oldProps), newProps);\n  },\n\n  /**\n   * @lends {ReactPropTransferer.prototype}\n   */\n  Mixin: {\n    /**\n     * Transfer props from this component to a target component.\n     *\n     * Props that do not have an explicit transfer strategy will be transferred\n     * only if the target component does not already have the prop set.\n     *\n     * This is usually used to pass down props to a returned root component.\n     *\n     * @param {ReactElement} element Component receiving the properties.\n     * @return {ReactElement} The supplied `component`.\n     * @final\n     * @protected\n     */\n    transferPropsTo: function (element) {\n      \"production\" !== process.env.NODE_ENV ? invariant(element._owner === this, '%s: You can\\'t call transferPropsTo() on a component that you ' + 'don\\'t own, %s. This usually means you are calling ' + 'transferPropsTo() on a component passed in as props or children.', this.constructor.displayName, typeof element.type === 'string' ? element.type : element.type.displayName) : invariant(element._owner === this);\n\n      if (\"production\" !== process.env.NODE_ENV) {\n        if (!didWarn) {\n          didWarn = true;\n          \"production\" !== process.env.NODE_ENV ? warning(false, 'transferPropsTo is deprecated. ' + 'See http://fb.me/react-transferpropsto for more information.') : null;\n        }\n      } // Because elements are immutable we have to merge into the existing\n      // props object rather than clone it.\n\n\n      transferInto(element.props, this.props);\n      return element;\n    }\n  }\n};\nmodule.exports = ReactPropTransferer;","map":{"version":3,"sources":["/Users/ejmaltes/Desktop/Personal-Website/node_modules/react-object-fit-cover/node_modules/react/lib/ReactPropTransferer.js"],"names":["assign","require","emptyFunction","invariant","joinClasses","warning","didWarn","createTransferStrategy","mergeStrategy","props","key","value","hasOwnProperty","transferStrategyMerge","a","b","TransferStrategies","children","className","style","transferInto","newProps","thisKey","transferStrategy","ReactPropTransferer","mergeProps","oldProps","Mixin","transferPropsTo","element","process","env","NODE_ENV","_owner","constructor","displayName","type","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactPropTransferer\n */\n\n\"use strict\";\n\nvar assign = require(\"./Object.assign\");\nvar emptyFunction = require(\"./emptyFunction\");\nvar invariant = require(\"./invariant\");\nvar joinClasses = require(\"./joinClasses\");\nvar warning = require(\"./warning\");\n\nvar didWarn = false;\n\n/**\n * Creates a transfer strategy that will merge prop values using the supplied\n * `mergeStrategy`. If a prop was previously unset, this just sets it.\n *\n * @param {function} mergeStrategy\n * @return {function}\n */\nfunction createTransferStrategy(mergeStrategy) {\n  return function(props, key, value) {\n    if (!props.hasOwnProperty(key)) {\n      props[key] = value;\n    } else {\n      props[key] = mergeStrategy(props[key], value);\n    }\n  };\n}\n\nvar transferStrategyMerge = createTransferStrategy(function(a, b) {\n  // `merge` overrides the first object's (`props[key]` above) keys using the\n  // second object's (`value`) keys. An object's style's existing `propA` would\n  // get overridden. Flip the order here.\n  return assign({}, b, a);\n});\n\n/**\n * Transfer strategies dictate how props are transferred by `transferPropsTo`.\n * NOTE: if you add any more exceptions to this list you should be sure to\n * update `cloneWithProps()` accordingly.\n */\nvar TransferStrategies = {\n  /**\n   * Never transfer `children`.\n   */\n  children: emptyFunction,\n  /**\n   * Transfer the `className` prop by merging them.\n   */\n  className: createTransferStrategy(joinClasses),\n  /**\n   * Transfer the `style` prop (which is an object) by merging them.\n   */\n  style: transferStrategyMerge\n};\n\n/**\n * Mutates the first argument by transferring the properties from the second\n * argument.\n *\n * @param {object} props\n * @param {object} newProps\n * @return {object}\n */\nfunction transferInto(props, newProps) {\n  for (var thisKey in newProps) {\n    if (!newProps.hasOwnProperty(thisKey)) {\n      continue;\n    }\n\n    var transferStrategy = TransferStrategies[thisKey];\n\n    if (transferStrategy && TransferStrategies.hasOwnProperty(thisKey)) {\n      transferStrategy(props, thisKey, newProps[thisKey]);\n    } else if (!props.hasOwnProperty(thisKey)) {\n      props[thisKey] = newProps[thisKey];\n    }\n  }\n  return props;\n}\n\n/**\n * ReactPropTransferer are capable of transferring props to another component\n * using a `transferPropsTo` method.\n *\n * @class ReactPropTransferer\n */\nvar ReactPropTransferer = {\n\n  TransferStrategies: TransferStrategies,\n\n  /**\n   * Merge two props objects using TransferStrategies.\n   *\n   * @param {object} oldProps original props (they take precedence)\n   * @param {object} newProps new props to merge in\n   * @return {object} a new object containing both sets of props merged.\n   */\n  mergeProps: function(oldProps, newProps) {\n    return transferInto(assign({}, oldProps), newProps);\n  },\n\n  /**\n   * @lends {ReactPropTransferer.prototype}\n   */\n  Mixin: {\n\n    /**\n     * Transfer props from this component to a target component.\n     *\n     * Props that do not have an explicit transfer strategy will be transferred\n     * only if the target component does not already have the prop set.\n     *\n     * This is usually used to pass down props to a returned root component.\n     *\n     * @param {ReactElement} element Component receiving the properties.\n     * @return {ReactElement} The supplied `component`.\n     * @final\n     * @protected\n     */\n    transferPropsTo: function(element) {\n      (\"production\" !== process.env.NODE_ENV ? invariant(\n        element._owner === this,\n        '%s: You can\\'t call transferPropsTo() on a component that you ' +\n        'don\\'t own, %s. This usually means you are calling ' +\n        'transferPropsTo() on a component passed in as props or children.',\n        this.constructor.displayName,\n        typeof element.type === 'string' ?\n        element.type :\n        element.type.displayName\n      ) : invariant(element._owner === this));\n\n      if (\"production\" !== process.env.NODE_ENV) {\n        if (!didWarn) {\n          didWarn = true;\n          (\"production\" !== process.env.NODE_ENV ? warning(\n            false,\n            'transferPropsTo is deprecated. ' +\n            'See http://fb.me/react-transferpropsto for more information.'\n          ) : null);\n        }\n      }\n\n      // Because elements are immutable we have to merge into the existing\n      // props object rather than clone it.\n      transferInto(element.props, this.props);\n\n      return element;\n    }\n\n  }\n};\n\nmodule.exports = ReactPropTransferer;\n"]},"metadata":{},"sourceType":"script"}