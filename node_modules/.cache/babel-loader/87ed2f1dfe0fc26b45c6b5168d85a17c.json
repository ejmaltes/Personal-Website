{"ast":null,"code":"/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactCompositeComponent\n */\n\"use strict\";\n\nvar ReactComponent = require(\"./ReactComponent\");\n\nvar ReactContext = require(\"./ReactContext\");\n\nvar ReactCurrentOwner = require(\"./ReactCurrentOwner\");\n\nvar ReactElement = require(\"./ReactElement\");\n\nvar ReactElementValidator = require(\"./ReactElementValidator\");\n\nvar ReactEmptyComponent = require(\"./ReactEmptyComponent\");\n\nvar ReactErrorUtils = require(\"./ReactErrorUtils\");\n\nvar ReactLegacyElement = require(\"./ReactLegacyElement\");\n\nvar ReactOwner = require(\"./ReactOwner\");\n\nvar ReactPerf = require(\"./ReactPerf\");\n\nvar ReactPropTransferer = require(\"./ReactPropTransferer\");\n\nvar ReactPropTypeLocations = require(\"./ReactPropTypeLocations\");\n\nvar ReactPropTypeLocationNames = require(\"./ReactPropTypeLocationNames\");\n\nvar ReactUpdates = require(\"./ReactUpdates\");\n\nvar assign = require(\"./Object.assign\");\n\nvar instantiateReactComponent = require(\"./instantiateReactComponent\");\n\nvar invariant = require(\"./invariant\");\n\nvar keyMirror = require(\"./keyMirror\");\n\nvar keyOf = require(\"./keyOf\");\n\nvar monitorCodeUse = require(\"./monitorCodeUse\");\n\nvar mapObject = require(\"./mapObject\");\n\nvar shouldUpdateReactComponent = require(\"./shouldUpdateReactComponent\");\n\nvar warning = require(\"./warning\");\n\nvar MIXINS_KEY = keyOf({\n  mixins: null\n});\n/**\n * Policies that describe methods in `ReactCompositeComponentInterface`.\n */\n\nvar SpecPolicy = keyMirror({\n  /**\n   * These methods may be defined only once by the class specification or mixin.\n   */\n  DEFINE_ONCE: null,\n\n  /**\n   * These methods may be defined by both the class specification and mixins.\n   * Subsequent definitions will be chained. These methods must return void.\n   */\n  DEFINE_MANY: null,\n\n  /**\n   * These methods are overriding the base ReactCompositeComponent class.\n   */\n  OVERRIDE_BASE: null,\n\n  /**\n   * These methods are similar to DEFINE_MANY, except we assume they return\n   * objects. We try to merge the keys of the return values of all the mixed in\n   * functions. If there is a key conflict we throw.\n   */\n  DEFINE_MANY_MERGED: null\n});\nvar injectedMixins = [];\n/**\n * Composite components are higher-level components that compose other composite\n * or native components.\n *\n * To create a new type of `ReactCompositeComponent`, pass a specification of\n * your new class to `React.createClass`. The only requirement of your class\n * specification is that you implement a `render` method.\n *\n *   var MyComponent = React.createClass({\n *     render: function() {\n *       return <div>Hello World</div>;\n *     }\n *   });\n *\n * The class specification supports a specific protocol of methods that have\n * special meaning (e.g. `render`). See `ReactCompositeComponentInterface` for\n * more the comprehensive protocol. Any other properties and methods in the\n * class specification will available on the prototype.\n *\n * @interface ReactCompositeComponentInterface\n * @internal\n */\n\nvar ReactCompositeComponentInterface = {\n  /**\n   * An array of Mixin objects to include when defining your component.\n   *\n   * @type {array}\n   * @optional\n   */\n  mixins: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * An object containing properties and methods that should be defined on\n   * the component's constructor instead of its prototype (static methods).\n   *\n   * @type {object}\n   * @optional\n   */\n  statics: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * Definition of prop types for this component.\n   *\n   * @type {object}\n   * @optional\n   */\n  propTypes: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * Definition of context types for this component.\n   *\n   * @type {object}\n   * @optional\n   */\n  contextTypes: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * Definition of context types this component sets for its children.\n   *\n   * @type {object}\n   * @optional\n   */\n  childContextTypes: SpecPolicy.DEFINE_MANY,\n  // ==== Definition methods ====\n\n  /**\n   * Invoked when the component is mounted. Values in the mapping will be set on\n   * `this.props` if that prop is not specified (i.e. using an `in` check).\n   *\n   * This method is invoked before `getInitialState` and therefore cannot rely\n   * on `this.state` or use `this.setState`.\n   *\n   * @return {object}\n   * @optional\n   */\n  getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,\n\n  /**\n   * Invoked once before the component is mounted. The return value will be used\n   * as the initial value of `this.state`.\n   *\n   *   getInitialState: function() {\n   *     return {\n   *       isOn: false,\n   *       fooBaz: new BazFoo()\n   *     }\n   *   }\n   *\n   * @return {object}\n   * @optional\n   */\n  getInitialState: SpecPolicy.DEFINE_MANY_MERGED,\n\n  /**\n   * @return {object}\n   * @optional\n   */\n  getChildContext: SpecPolicy.DEFINE_MANY_MERGED,\n\n  /**\n   * Uses props from `this.props` and state from `this.state` to render the\n   * structure of the component.\n   *\n   * No guarantees are made about when or how often this method is invoked, so\n   * it must not have side effects.\n   *\n   *   render: function() {\n   *     var name = this.props.name;\n   *     return <div>Hello, {name}!</div>;\n   *   }\n   *\n   * @return {ReactComponent}\n   * @nosideeffects\n   * @required\n   */\n  render: SpecPolicy.DEFINE_ONCE,\n  // ==== Delegate methods ====\n\n  /**\n   * Invoked when the component is initially created and about to be mounted.\n   * This may have side effects, but any external subscriptions or data created\n   * by this method must be cleaned up in `componentWillUnmount`.\n   *\n   * @optional\n   */\n  componentWillMount: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * Invoked when the component has been mounted and has a DOM representation.\n   * However, there is no guarantee that the DOM node is in the document.\n   *\n   * Use this as an opportunity to operate on the DOM when the component has\n   * been mounted (initialized and rendered) for the first time.\n   *\n   * @param {DOMElement} rootNode DOM element representing the component.\n   * @optional\n   */\n  componentDidMount: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * Invoked before the component receives new props.\n   *\n   * Use this as an opportunity to react to a prop transition by updating the\n   * state using `this.setState`. Current props are accessed via `this.props`.\n   *\n   *   componentWillReceiveProps: function(nextProps, nextContext) {\n   *     this.setState({\n   *       likesIncreasing: nextProps.likeCount > this.props.likeCount\n   *     });\n   *   }\n   *\n   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop\n   * transition may cause a state change, but the opposite is not true. If you\n   * need it, you are probably looking for `componentWillUpdate`.\n   *\n   * @param {object} nextProps\n   * @optional\n   */\n  componentWillReceiveProps: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * Invoked while deciding if the component should be updated as a result of\n   * receiving new props, state and/or context.\n   *\n   * Use this as an opportunity to `return false` when you're certain that the\n   * transition to the new props/state/context will not require a component\n   * update.\n   *\n   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {\n   *     return !equal(nextProps, this.props) ||\n   *       !equal(nextState, this.state) ||\n   *       !equal(nextContext, this.context);\n   *   }\n   *\n   * @param {object} nextProps\n   * @param {?object} nextState\n   * @param {?object} nextContext\n   * @return {boolean} True if the component should update.\n   * @optional\n   */\n  shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,\n\n  /**\n   * Invoked when the component is about to update due to a transition from\n   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`\n   * and `nextContext`.\n   *\n   * Use this as an opportunity to perform preparation before an update occurs.\n   *\n   * NOTE: You **cannot** use `this.setState()` in this method.\n   *\n   * @param {object} nextProps\n   * @param {?object} nextState\n   * @param {?object} nextContext\n   * @param {ReactReconcileTransaction} transaction\n   * @optional\n   */\n  componentWillUpdate: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * Invoked when the component's DOM representation has been updated.\n   *\n   * Use this as an opportunity to operate on the DOM when the component has\n   * been updated.\n   *\n   * @param {object} prevProps\n   * @param {?object} prevState\n   * @param {?object} prevContext\n   * @param {DOMElement} rootNode DOM element representing the component.\n   * @optional\n   */\n  componentDidUpdate: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * Invoked when the component is about to be removed from its parent and have\n   * its DOM representation destroyed.\n   *\n   * Use this as an opportunity to deallocate any external resources.\n   *\n   * NOTE: There is no `componentDidUnmount` since your component will have been\n   * destroyed by that point.\n   *\n   * @optional\n   */\n  componentWillUnmount: SpecPolicy.DEFINE_MANY,\n  // ==== Advanced methods ====\n\n  /**\n   * Updates the component's currently mounted DOM representation.\n   *\n   * By default, this implements React's rendering and reconciliation algorithm.\n   * Sophisticated clients may wish to override this.\n   *\n   * @param {ReactReconcileTransaction} transaction\n   * @internal\n   * @overridable\n   */\n  updateComponent: SpecPolicy.OVERRIDE_BASE\n};\n/**\n * Mapping from class specification keys to special processing functions.\n *\n * Although these are declared like instance properties in the specification\n * when defining classes using `React.createClass`, they are actually static\n * and are accessible on the constructor instead of the prototype. Despite\n * being static, they must be defined outside of the \"statics\" key under\n * which all other static methods are defined.\n */\n\nvar RESERVED_SPEC_KEYS = {\n  displayName: function (Constructor, displayName) {\n    Constructor.displayName = displayName;\n  },\n  mixins: function (Constructor, mixins) {\n    if (mixins) {\n      for (var i = 0; i < mixins.length; i++) {\n        mixSpecIntoComponent(Constructor, mixins[i]);\n      }\n    }\n  },\n  childContextTypes: function (Constructor, childContextTypes) {\n    validateTypeDef(Constructor, childContextTypes, ReactPropTypeLocations.childContext);\n    Constructor.childContextTypes = assign({}, Constructor.childContextTypes, childContextTypes);\n  },\n  contextTypes: function (Constructor, contextTypes) {\n    validateTypeDef(Constructor, contextTypes, ReactPropTypeLocations.context);\n    Constructor.contextTypes = assign({}, Constructor.contextTypes, contextTypes);\n  },\n\n  /**\n   * Special case getDefaultProps which should move into statics but requires\n   * automatic merging.\n   */\n  getDefaultProps: function (Constructor, getDefaultProps) {\n    if (Constructor.getDefaultProps) {\n      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);\n    } else {\n      Constructor.getDefaultProps = getDefaultProps;\n    }\n  },\n  propTypes: function (Constructor, propTypes) {\n    validateTypeDef(Constructor, propTypes, ReactPropTypeLocations.prop);\n    Constructor.propTypes = assign({}, Constructor.propTypes, propTypes);\n  },\n  statics: function (Constructor, statics) {\n    mixStaticSpecIntoComponent(Constructor, statics);\n  }\n};\n\nfunction getDeclarationErrorAddendum(component) {\n  var owner = component._owner || null;\n\n  if (owner && owner.constructor && owner.constructor.displayName) {\n    return ' Check the render method of `' + owner.constructor.displayName + '`.';\n  }\n\n  return '';\n}\n\nfunction validateTypeDef(Constructor, typeDef, location) {\n  for (var propName in typeDef) {\n    if (typeDef.hasOwnProperty(propName)) {\n      \"production\" !== process.env.NODE_ENV ? invariant(typeof typeDef[propName] == 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactCompositeComponent', ReactPropTypeLocationNames[location], propName) : invariant(typeof typeDef[propName] == 'function');\n    }\n  }\n}\n\nfunction validateMethodOverride(proto, name) {\n  var specPolicy = ReactCompositeComponentInterface.hasOwnProperty(name) ? ReactCompositeComponentInterface[name] : null; // Disallow overriding of base class methods unless explicitly allowed.\n\n  if (ReactCompositeComponentMixin.hasOwnProperty(name)) {\n    \"production\" !== process.env.NODE_ENV ? invariant(specPolicy === SpecPolicy.OVERRIDE_BASE, 'ReactCompositeComponentInterface: You are attempting to override ' + '`%s` from your class specification. Ensure that your method names ' + 'do not overlap with React methods.', name) : invariant(specPolicy === SpecPolicy.OVERRIDE_BASE);\n  } // Disallow defining methods more than once unless explicitly allowed.\n\n\n  if (proto.hasOwnProperty(name)) {\n    \"production\" !== process.env.NODE_ENV ? invariant(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED, 'ReactCompositeComponentInterface: You are attempting to define ' + '`%s` on your component more than once. This conflict may be due ' + 'to a mixin.', name) : invariant(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED);\n  }\n}\n\nfunction validateLifeCycleOnReplaceState(instance) {\n  var compositeLifeCycleState = instance._compositeLifeCycleState;\n  \"production\" !== process.env.NODE_ENV ? invariant(instance.isMounted() || compositeLifeCycleState === CompositeLifeCycle.MOUNTING, 'replaceState(...): Can only update a mounted or mounting component.') : invariant(instance.isMounted() || compositeLifeCycleState === CompositeLifeCycle.MOUNTING);\n  \"production\" !== process.env.NODE_ENV ? invariant(ReactCurrentOwner.current == null, 'replaceState(...): Cannot update during an existing state transition ' + '(such as within `render`). Render methods should be a pure function ' + 'of props and state.') : invariant(ReactCurrentOwner.current == null);\n  \"production\" !== process.env.NODE_ENV ? invariant(compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING, 'replaceState(...): Cannot update while unmounting component. This ' + 'usually means you called setState() on an unmounted component.') : invariant(compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING);\n}\n/**\n * Mixin helper which handles policy validation and reserved\n * specification keys when building `ReactCompositeComponent` classses.\n */\n\n\nfunction mixSpecIntoComponent(Constructor, spec) {\n  if (!spec) {\n    return;\n  }\n\n  \"production\" !== process.env.NODE_ENV ? invariant(!ReactLegacyElement.isValidFactory(spec), 'ReactCompositeComponent: You\\'re attempting to ' + 'use a component class as a mixin. Instead, just use a regular object.') : invariant(!ReactLegacyElement.isValidFactory(spec));\n  \"production\" !== process.env.NODE_ENV ? invariant(!ReactElement.isValidElement(spec), 'ReactCompositeComponent: You\\'re attempting to ' + 'use a component as a mixin. Instead, just use a regular object.') : invariant(!ReactElement.isValidElement(spec));\n  var proto = Constructor.prototype; // By handling mixins before any other properties, we ensure the same\n  // chaining order is applied to methods with DEFINE_MANY policy, whether\n  // mixins are listed before or after these methods in the spec.\n\n  if (spec.hasOwnProperty(MIXINS_KEY)) {\n    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);\n  }\n\n  for (var name in spec) {\n    if (!spec.hasOwnProperty(name)) {\n      continue;\n    }\n\n    if (name === MIXINS_KEY) {\n      // We have already handled mixins in a special case above\n      continue;\n    }\n\n    var property = spec[name];\n    validateMethodOverride(proto, name);\n\n    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {\n      RESERVED_SPEC_KEYS[name](Constructor, property);\n    } else {\n      // Setup methods on prototype:\n      // The following member methods should not be automatically bound:\n      // 1. Expected ReactCompositeComponent methods (in the \"interface\").\n      // 2. Overridden methods (that were mixed in).\n      var isCompositeComponentMethod = ReactCompositeComponentInterface.hasOwnProperty(name);\n      var isAlreadyDefined = proto.hasOwnProperty(name);\n      var markedDontBind = property && property.__reactDontBind;\n      var isFunction = typeof property === 'function';\n      var shouldAutoBind = isFunction && !isCompositeComponentMethod && !isAlreadyDefined && !markedDontBind;\n\n      if (shouldAutoBind) {\n        if (!proto.__reactAutoBindMap) {\n          proto.__reactAutoBindMap = {};\n        }\n\n        proto.__reactAutoBindMap[name] = property;\n        proto[name] = property;\n      } else {\n        if (isAlreadyDefined) {\n          var specPolicy = ReactCompositeComponentInterface[name]; // These cases should already be caught by validateMethodOverride\n\n          \"production\" !== process.env.NODE_ENV ? invariant(isCompositeComponentMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY), 'ReactCompositeComponent: Unexpected spec policy %s for key %s ' + 'when mixing in component specs.', specPolicy, name) : invariant(isCompositeComponentMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY)); // For methods which are defined more than once, call the existing\n          // methods before calling the new property, merging if appropriate.\n\n          if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {\n            proto[name] = createMergedResultFunction(proto[name], property);\n          } else if (specPolicy === SpecPolicy.DEFINE_MANY) {\n            proto[name] = createChainedFunction(proto[name], property);\n          }\n        } else {\n          proto[name] = property;\n\n          if (\"production\" !== process.env.NODE_ENV) {\n            // Add verbose displayName to the function, which helps when looking\n            // at profiling tools.\n            if (typeof property === 'function' && spec.displayName) {\n              proto[name].displayName = spec.displayName + '_' + name;\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction mixStaticSpecIntoComponent(Constructor, statics) {\n  if (!statics) {\n    return;\n  }\n\n  for (var name in statics) {\n    var property = statics[name];\n\n    if (!statics.hasOwnProperty(name)) {\n      continue;\n    }\n\n    var isReserved = (name in RESERVED_SPEC_KEYS);\n    \"production\" !== process.env.NODE_ENV ? invariant(!isReserved, 'ReactCompositeComponent: You are attempting to define a reserved ' + 'property, `%s`, that shouldn\\'t be on the \"statics\" key. Define it ' + 'as an instance property instead; it will still be accessible on the ' + 'constructor.', name) : invariant(!isReserved);\n    var isInherited = (name in Constructor);\n    \"production\" !== process.env.NODE_ENV ? invariant(!isInherited, 'ReactCompositeComponent: You are attempting to define ' + '`%s` on your component more than once. This conflict may be ' + 'due to a mixin.', name) : invariant(!isInherited);\n    Constructor[name] = property;\n  }\n}\n/**\n * Merge two objects, but throw if both contain the same key.\n *\n * @param {object} one The first object, which is mutated.\n * @param {object} two The second object\n * @return {object} one after it has been mutated to contain everything in two.\n */\n\n\nfunction mergeObjectsWithNoDuplicateKeys(one, two) {\n  \"production\" !== process.env.NODE_ENV ? invariant(one && two && typeof one === 'object' && typeof two === 'object', 'mergeObjectsWithNoDuplicateKeys(): Cannot merge non-objects') : invariant(one && two && typeof one === 'object' && typeof two === 'object');\n  mapObject(two, function (value, key) {\n    \"production\" !== process.env.NODE_ENV ? invariant(one[key] === undefined, 'mergeObjectsWithNoDuplicateKeys(): ' + 'Tried to merge two objects with the same key: `%s`. This conflict ' + 'may be due to a mixin; in particular, this may be caused by two ' + 'getInitialState() or getDefaultProps() methods returning objects ' + 'with clashing keys.', key) : invariant(one[key] === undefined);\n    one[key] = value;\n  });\n  return one;\n}\n/**\n * Creates a function that invokes two functions and merges their return values.\n *\n * @param {function} one Function to invoke first.\n * @param {function} two Function to invoke second.\n * @return {function} Function that invokes the two argument functions.\n * @private\n */\n\n\nfunction createMergedResultFunction(one, two) {\n  return function mergedResult() {\n    var a = one.apply(this, arguments);\n    var b = two.apply(this, arguments);\n\n    if (a == null) {\n      return b;\n    } else if (b == null) {\n      return a;\n    }\n\n    return mergeObjectsWithNoDuplicateKeys(a, b);\n  };\n}\n/**\n * Creates a function that invokes two functions and ignores their return vales.\n *\n * @param {function} one Function to invoke first.\n * @param {function} two Function to invoke second.\n * @return {function} Function that invokes the two argument functions.\n * @private\n */\n\n\nfunction createChainedFunction(one, two) {\n  return function chainedFunction() {\n    one.apply(this, arguments);\n    two.apply(this, arguments);\n  };\n}\n/**\n * `ReactCompositeComponent` maintains an auxiliary life cycle state in\n * `this._compositeLifeCycleState` (which can be null).\n *\n * This is different from the life cycle state maintained by `ReactComponent` in\n * `this._lifeCycleState`. The following diagram shows how the states overlap in\n * time. There are times when the CompositeLifeCycle is null - at those times it\n * is only meaningful to look at ComponentLifeCycle alone.\n *\n * Top Row: ReactComponent.ComponentLifeCycle\n * Low Row: ReactComponent.CompositeLifeCycle\n *\n * +-------+---------------------------------+--------+\n * |  UN   |             MOUNTED             |   UN   |\n * |MOUNTED|                                 | MOUNTED|\n * +-------+---------------------------------+--------+\n * |       ^--------+   +-------+   +--------^        |\n * |       |        |   |       |   |        |        |\n * |    0--|MOUNTING|-0-|RECEIVE|-0-|   UN   |--->0   |\n * |       |        |   |PROPS  |   |MOUNTING|        |\n * |       |        |   |       |   |        |        |\n * |       |        |   |       |   |        |        |\n * |       +--------+   +-------+   +--------+        |\n * |       |                                 |        |\n * +-------+---------------------------------+--------+\n */\n\n\nvar CompositeLifeCycle = keyMirror({\n  /**\n   * Components in the process of being mounted respond to state changes\n   * differently.\n   */\n  MOUNTING: null,\n\n  /**\n   * Components in the process of being unmounted are guarded against state\n   * changes.\n   */\n  UNMOUNTING: null,\n\n  /**\n   * Components that are mounted and receiving new props respond to state\n   * changes differently.\n   */\n  RECEIVING_PROPS: null\n});\n/**\n * @lends {ReactCompositeComponent.prototype}\n */\n\nvar ReactCompositeComponentMixin = {\n  /**\n   * Base constructor for all composite component.\n   *\n   * @param {ReactElement} element\n   * @final\n   * @internal\n   */\n  construct: function (element) {\n    // Children can be either an array or more than one argument\n    ReactComponent.Mixin.construct.apply(this, arguments);\n    ReactOwner.Mixin.construct.apply(this, arguments);\n    this.state = null;\n    this._pendingState = null; // This is the public post-processed context. The real context and pending\n    // context lives on the element.\n\n    this.context = null;\n    this._compositeLifeCycleState = null;\n  },\n\n  /**\n   * Checks whether or not this composite component is mounted.\n   * @return {boolean} True if mounted, false otherwise.\n   * @protected\n   * @final\n   */\n  isMounted: function () {\n    return ReactComponent.Mixin.isMounted.call(this) && this._compositeLifeCycleState !== CompositeLifeCycle.MOUNTING;\n  },\n\n  /**\n   * Initializes the component, renders markup, and registers event listeners.\n   *\n   * @param {string} rootID DOM ID of the root node.\n   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\n   * @param {number} mountDepth number of components in the owner hierarchy\n   * @return {?string} Rendered markup to be inserted into the DOM.\n   * @final\n   * @internal\n   */\n  mountComponent: ReactPerf.measure('ReactCompositeComponent', 'mountComponent', function (rootID, transaction, mountDepth) {\n    ReactComponent.Mixin.mountComponent.call(this, rootID, transaction, mountDepth);\n    this._compositeLifeCycleState = CompositeLifeCycle.MOUNTING;\n\n    if (this.__reactAutoBindMap) {\n      this._bindAutoBindMethods();\n    }\n\n    this.context = this._processContext(this._currentElement._context);\n    this.props = this._processProps(this.props);\n    this.state = this.getInitialState ? this.getInitialState() : null;\n    \"production\" !== process.env.NODE_ENV ? invariant(typeof this.state === 'object' && !Array.isArray(this.state), '%s.getInitialState(): must return an object or null', this.constructor.displayName || 'ReactCompositeComponent') : invariant(typeof this.state === 'object' && !Array.isArray(this.state));\n    this._pendingState = null;\n    this._pendingForceUpdate = false;\n\n    if (this.componentWillMount) {\n      this.componentWillMount(); // When mounting, calls to `setState` by `componentWillMount` will set\n      // `this._pendingState` without triggering a re-render.\n\n      if (this._pendingState) {\n        this.state = this._pendingState;\n        this._pendingState = null;\n      }\n    }\n\n    this._renderedComponent = instantiateReactComponent(this._renderValidatedComponent(), this._currentElement.type // The wrapping type\n    ); // Done with mounting, `setState` will now trigger UI changes.\n\n    this._compositeLifeCycleState = null;\n\n    var markup = this._renderedComponent.mountComponent(rootID, transaction, mountDepth + 1);\n\n    if (this.componentDidMount) {\n      transaction.getReactMountReady().enqueue(this.componentDidMount, this);\n    }\n\n    return markup;\n  }),\n\n  /**\n   * Releases any resources allocated by `mountComponent`.\n   *\n   * @final\n   * @internal\n   */\n  unmountComponent: function () {\n    this._compositeLifeCycleState = CompositeLifeCycle.UNMOUNTING;\n\n    if (this.componentWillUnmount) {\n      this.componentWillUnmount();\n    }\n\n    this._compositeLifeCycleState = null;\n\n    this._renderedComponent.unmountComponent();\n\n    this._renderedComponent = null;\n    ReactComponent.Mixin.unmountComponent.call(this); // Some existing components rely on this.props even after they've been\n    // destroyed (in event handlers).\n    // TODO: this.props = null;\n    // TODO: this.state = null;\n  },\n\n  /**\n   * Sets a subset of the state. Always use this or `replaceState` to mutate\n   * state. You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * There is no guarantee that calls to `setState` will run synchronously,\n   * as they may eventually be batched together.  You can provide an optional\n   * callback that will be executed when the call to setState is actually\n   * completed.\n   *\n   * @param {object} partialState Next partial state to be merged with state.\n   * @param {?function} callback Called after state is updated.\n   * @final\n   * @protected\n   */\n  setState: function (partialState, callback) {\n    \"production\" !== process.env.NODE_ENV ? invariant(typeof partialState === 'object' || partialState == null, 'setState(...): takes an object of state variables to update.') : invariant(typeof partialState === 'object' || partialState == null);\n\n    if (\"production\" !== process.env.NODE_ENV) {\n      \"production\" !== process.env.NODE_ENV ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : null;\n    } // Merge with `_pendingState` if it exists, otherwise with existing state.\n\n\n    this.replaceState(assign({}, this._pendingState || this.state, partialState), callback);\n  },\n\n  /**\n   * Replaces all of the state. Always use this or `setState` to mutate state.\n   * You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * @param {object} completeState Next state.\n   * @param {?function} callback Called after state is updated.\n   * @final\n   * @protected\n   */\n  replaceState: function (completeState, callback) {\n    validateLifeCycleOnReplaceState(this);\n    this._pendingState = completeState;\n\n    if (this._compositeLifeCycleState !== CompositeLifeCycle.MOUNTING) {\n      // If we're in a componentWillMount handler, don't enqueue a rerender\n      // because ReactUpdates assumes we're in a browser context (which is wrong\n      // for server rendering) and we're about to do a render anyway.\n      // TODO: The callback here is ignored when setState is called from\n      // componentWillMount. Either fix it or disallow doing so completely in\n      // favor of getInitialState.\n      ReactUpdates.enqueueUpdate(this, callback);\n    }\n  },\n\n  /**\n   * Filters the context object to only contain keys specified in\n   * `contextTypes`, and asserts that they are valid.\n   *\n   * @param {object} context\n   * @return {?object}\n   * @private\n   */\n  _processContext: function (context) {\n    var maskedContext = null;\n    var contextTypes = this.constructor.contextTypes;\n\n    if (contextTypes) {\n      maskedContext = {};\n\n      for (var contextName in contextTypes) {\n        maskedContext[contextName] = context[contextName];\n      }\n\n      if (\"production\" !== process.env.NODE_ENV) {\n        this._checkPropTypes(contextTypes, maskedContext, ReactPropTypeLocations.context);\n      }\n    }\n\n    return maskedContext;\n  },\n\n  /**\n   * @param {object} currentContext\n   * @return {object}\n   * @private\n   */\n  _processChildContext: function (currentContext) {\n    var childContext = this.getChildContext && this.getChildContext();\n    var displayName = this.constructor.displayName || 'ReactCompositeComponent';\n\n    if (childContext) {\n      \"production\" !== process.env.NODE_ENV ? invariant(typeof this.constructor.childContextTypes === 'object', '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', displayName) : invariant(typeof this.constructor.childContextTypes === 'object');\n\n      if (\"production\" !== process.env.NODE_ENV) {\n        this._checkPropTypes(this.constructor.childContextTypes, childContext, ReactPropTypeLocations.childContext);\n      }\n\n      for (var name in childContext) {\n        \"production\" !== process.env.NODE_ENV ? invariant(name in this.constructor.childContextTypes, '%s.getChildContext(): key \"%s\" is not defined in childContextTypes.', displayName, name) : invariant(name in this.constructor.childContextTypes);\n      }\n\n      return assign({}, currentContext, childContext);\n    }\n\n    return currentContext;\n  },\n\n  /**\n   * Processes props by setting default values for unspecified props and\n   * asserting that the props are valid. Does not mutate its argument; returns\n   * a new props object with defaults merged in.\n   *\n   * @param {object} newProps\n   * @return {object}\n   * @private\n   */\n  _processProps: function (newProps) {\n    if (\"production\" !== process.env.NODE_ENV) {\n      var propTypes = this.constructor.propTypes;\n\n      if (propTypes) {\n        this._checkPropTypes(propTypes, newProps, ReactPropTypeLocations.prop);\n      }\n    }\n\n    return newProps;\n  },\n\n  /**\n   * Assert that the props are valid\n   *\n   * @param {object} propTypes Map of prop name to a ReactPropType\n   * @param {object} props\n   * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n   * @private\n   */\n  _checkPropTypes: function (propTypes, props, location) {\n    // TODO: Stop validating prop types here and only use the element\n    // validation.\n    var componentName = this.constructor.displayName;\n\n    for (var propName in propTypes) {\n      if (propTypes.hasOwnProperty(propName)) {\n        var error = propTypes[propName](props, propName, componentName, location);\n\n        if (error instanceof Error) {\n          // We may want to extend this logic for similar errors in\n          // renderComponent calls, so I'm abstracting it away into\n          // a function to minimize refactoring in the future\n          var addendum = getDeclarationErrorAddendum(this);\n          \"production\" !== process.env.NODE_ENV ? warning(false, error.message + addendum) : null;\n        }\n      }\n    }\n  },\n\n  /**\n   * If any of `_pendingElement`, `_pendingState`, or `_pendingForceUpdate`\n   * is set, update the component.\n   *\n   * @param {ReactReconcileTransaction} transaction\n   * @internal\n   */\n  performUpdateIfNecessary: function (transaction) {\n    var compositeLifeCycleState = this._compositeLifeCycleState; // Do not trigger a state transition if we are in the middle of mounting or\n    // receiving props because both of those will already be doing this.\n\n    if (compositeLifeCycleState === CompositeLifeCycle.MOUNTING || compositeLifeCycleState === CompositeLifeCycle.RECEIVING_PROPS) {\n      return;\n    }\n\n    if (this._pendingElement == null && this._pendingState == null && !this._pendingForceUpdate) {\n      return;\n    }\n\n    var nextContext = this.context;\n    var nextProps = this.props;\n    var nextElement = this._currentElement;\n\n    if (this._pendingElement != null) {\n      nextElement = this._pendingElement;\n      nextContext = this._processContext(nextElement._context);\n      nextProps = this._processProps(nextElement.props);\n      this._pendingElement = null;\n      this._compositeLifeCycleState = CompositeLifeCycle.RECEIVING_PROPS;\n\n      if (this.componentWillReceiveProps) {\n        this.componentWillReceiveProps(nextProps, nextContext);\n      }\n    }\n\n    this._compositeLifeCycleState = null;\n    var nextState = this._pendingState || this.state;\n    this._pendingState = null;\n    var shouldUpdate = this._pendingForceUpdate || !this.shouldComponentUpdate || this.shouldComponentUpdate(nextProps, nextState, nextContext);\n\n    if (\"production\" !== process.env.NODE_ENV) {\n      if (typeof shouldUpdate === \"undefined\") {\n        console.warn((this.constructor.displayName || 'ReactCompositeComponent') + '.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.');\n      }\n    }\n\n    if (shouldUpdate) {\n      this._pendingForceUpdate = false; // Will set `this.props`, `this.state` and `this.context`.\n\n      this._performComponentUpdate(nextElement, nextProps, nextState, nextContext, transaction);\n    } else {\n      // If it's determined that a component should not update, we still want\n      // to set props and state.\n      this._currentElement = nextElement;\n      this.props = nextProps;\n      this.state = nextState;\n      this.context = nextContext; // Owner cannot change because shouldUpdateReactComponent doesn't allow\n      // it. TODO: Remove this._owner completely.\n\n      this._owner = nextElement._owner;\n    }\n  },\n\n  /**\n   * Merges new props and state, notifies delegate methods of update and\n   * performs update.\n   *\n   * @param {ReactElement} nextElement Next element\n   * @param {object} nextProps Next public object to set as properties.\n   * @param {?object} nextState Next object to set as state.\n   * @param {?object} nextContext Next public object to set as context.\n   * @param {ReactReconcileTransaction} transaction\n   * @private\n   */\n  _performComponentUpdate: function (nextElement, nextProps, nextState, nextContext, transaction) {\n    var prevElement = this._currentElement;\n    var prevProps = this.props;\n    var prevState = this.state;\n    var prevContext = this.context;\n\n    if (this.componentWillUpdate) {\n      this.componentWillUpdate(nextProps, nextState, nextContext);\n    }\n\n    this._currentElement = nextElement;\n    this.props = nextProps;\n    this.state = nextState;\n    this.context = nextContext; // Owner cannot change because shouldUpdateReactComponent doesn't allow\n    // it. TODO: Remove this._owner completely.\n\n    this._owner = nextElement._owner;\n    this.updateComponent(transaction, prevElement);\n\n    if (this.componentDidUpdate) {\n      transaction.getReactMountReady().enqueue(this.componentDidUpdate.bind(this, prevProps, prevState, prevContext), this);\n    }\n  },\n  receiveComponent: function (nextElement, transaction) {\n    if (nextElement === this._currentElement && nextElement._owner != null) {\n      // Since elements are immutable after the owner is rendered,\n      // we can do a cheap identity compare here to determine if this is a\n      // superfluous reconcile. It's possible for state to be mutable but such\n      // change should trigger an update of the owner which would recreate\n      // the element. We explicitly check for the existence of an owner since\n      // it's possible for a element created outside a composite to be\n      // deeply mutated and reused.\n      return;\n    }\n\n    ReactComponent.Mixin.receiveComponent.call(this, nextElement, transaction);\n  },\n\n  /**\n   * Updates the component's currently mounted DOM representation.\n   *\n   * By default, this implements React's rendering and reconciliation algorithm.\n   * Sophisticated clients may wish to override this.\n   *\n   * @param {ReactReconcileTransaction} transaction\n   * @param {ReactElement} prevElement\n   * @internal\n   * @overridable\n   */\n  updateComponent: ReactPerf.measure('ReactCompositeComponent', 'updateComponent', function (transaction, prevParentElement) {\n    ReactComponent.Mixin.updateComponent.call(this, transaction, prevParentElement);\n    var prevComponentInstance = this._renderedComponent;\n    var prevElement = prevComponentInstance._currentElement;\n\n    var nextElement = this._renderValidatedComponent();\n\n    if (shouldUpdateReactComponent(prevElement, nextElement)) {\n      prevComponentInstance.receiveComponent(nextElement, transaction);\n    } else {\n      // These two IDs are actually the same! But nothing should rely on that.\n      var thisID = this._rootNodeID;\n      var prevComponentID = prevComponentInstance._rootNodeID;\n      prevComponentInstance.unmountComponent();\n      this._renderedComponent = instantiateReactComponent(nextElement, this._currentElement.type);\n\n      var nextMarkup = this._renderedComponent.mountComponent(thisID, transaction, this._mountDepth + 1);\n\n      ReactComponent.BackendIDOperations.dangerouslyReplaceNodeWithMarkupByID(prevComponentID, nextMarkup);\n    }\n  }),\n\n  /**\n   * Forces an update. This should only be invoked when it is known with\n   * certainty that we are **not** in a DOM transaction.\n   *\n   * You may want to call this when you know that some deeper aspect of the\n   * component's state has changed but `setState` was not called.\n   *\n   * This will not invoke `shouldUpdateComponent`, but it will invoke\n   * `componentWillUpdate` and `componentDidUpdate`.\n   *\n   * @param {?function} callback Called after update is complete.\n   * @final\n   * @protected\n   */\n  forceUpdate: function (callback) {\n    var compositeLifeCycleState = this._compositeLifeCycleState;\n    \"production\" !== process.env.NODE_ENV ? invariant(this.isMounted() || compositeLifeCycleState === CompositeLifeCycle.MOUNTING, 'forceUpdate(...): Can only force an update on mounted or mounting ' + 'components.') : invariant(this.isMounted() || compositeLifeCycleState === CompositeLifeCycle.MOUNTING);\n    \"production\" !== process.env.NODE_ENV ? invariant(compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING && ReactCurrentOwner.current == null, 'forceUpdate(...): Cannot force an update while unmounting component ' + 'or within a `render` function.') : invariant(compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING && ReactCurrentOwner.current == null);\n    this._pendingForceUpdate = true;\n    ReactUpdates.enqueueUpdate(this, callback);\n  },\n\n  /**\n   * @private\n   */\n  _renderValidatedComponent: ReactPerf.measure('ReactCompositeComponent', '_renderValidatedComponent', function () {\n    var renderedComponent;\n    var previousContext = ReactContext.current;\n    ReactContext.current = this._processChildContext(this._currentElement._context);\n    ReactCurrentOwner.current = this;\n\n    try {\n      renderedComponent = this.render();\n\n      if (renderedComponent === null || renderedComponent === false) {\n        renderedComponent = ReactEmptyComponent.getEmptyComponent();\n        ReactEmptyComponent.registerNullComponentID(this._rootNodeID);\n      } else {\n        ReactEmptyComponent.deregisterNullComponentID(this._rootNodeID);\n      }\n    } finally {\n      ReactContext.current = previousContext;\n      ReactCurrentOwner.current = null;\n    }\n\n    \"production\" !== process.env.NODE_ENV ? invariant(ReactElement.isValidElement(renderedComponent), '%s.render(): A valid ReactComponent must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', this.constructor.displayName || 'ReactCompositeComponent') : invariant(ReactElement.isValidElement(renderedComponent));\n    return renderedComponent;\n  }),\n\n  /**\n   * @private\n   */\n  _bindAutoBindMethods: function () {\n    for (var autoBindKey in this.__reactAutoBindMap) {\n      if (!this.__reactAutoBindMap.hasOwnProperty(autoBindKey)) {\n        continue;\n      }\n\n      var method = this.__reactAutoBindMap[autoBindKey];\n      this[autoBindKey] = this._bindAutoBindMethod(ReactErrorUtils.guard(method, this.constructor.displayName + '.' + autoBindKey));\n    }\n  },\n\n  /**\n   * Binds a method to the component.\n   *\n   * @param {function} method Method to be bound.\n   * @private\n   */\n  _bindAutoBindMethod: function (method) {\n    var component = this;\n    var boundMethod = method.bind(component);\n\n    if (\"production\" !== process.env.NODE_ENV) {\n      boundMethod.__reactBoundContext = component;\n      boundMethod.__reactBoundMethod = method;\n      boundMethod.__reactBoundArguments = null;\n      var componentName = component.constructor.displayName;\n      var _bind = boundMethod.bind;\n\n      boundMethod.bind = function (newThis) {\n        for (var args = [], $__0 = 1, $__1 = arguments.length; $__0 < $__1; $__0++) args.push(arguments[$__0]); // User is trying to bind() an autobound method; we effectively will\n        // ignore the value of \"this\" that the user is trying to use, so\n        // let's warn.\n\n\n        if (newThis !== component && newThis !== null) {\n          monitorCodeUse('react_bind_warning', {\n            component: componentName\n          });\n          console.warn('bind(): React component methods may only be bound to the ' + 'component instance. See ' + componentName);\n        } else if (!args.length) {\n          monitorCodeUse('react_bind_warning', {\n            component: componentName\n          });\n          console.warn('bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See ' + componentName);\n          return boundMethod;\n        }\n\n        var reboundMethod = _bind.apply(boundMethod, arguments);\n\n        reboundMethod.__reactBoundContext = component;\n        reboundMethod.__reactBoundMethod = method;\n        reboundMethod.__reactBoundArguments = args;\n        return reboundMethod;\n      };\n    }\n\n    return boundMethod;\n  }\n};\n\nvar ReactCompositeComponentBase = function () {};\n\nassign(ReactCompositeComponentBase.prototype, ReactComponent.Mixin, ReactOwner.Mixin, ReactPropTransferer.Mixin, ReactCompositeComponentMixin);\n/**\n * Module for creating composite components.\n *\n * @class ReactCompositeComponent\n * @extends ReactComponent\n * @extends ReactOwner\n * @extends ReactPropTransferer\n */\n\nvar ReactCompositeComponent = {\n  LifeCycle: CompositeLifeCycle,\n  Base: ReactCompositeComponentBase,\n\n  /**\n   * Creates a composite component class given a class specification.\n   *\n   * @param {object} spec Class specification (which must define `render`).\n   * @return {function} Component constructor function.\n   * @public\n   */\n  createClass: function (spec) {\n    var Constructor = function (props) {// This constructor is overridden by mocks. The argument is used\n      // by mocks to assert on what gets mounted. This will later be used\n      // by the stand-alone class implementation.\n    };\n\n    Constructor.prototype = new ReactCompositeComponentBase();\n    Constructor.prototype.constructor = Constructor;\n    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));\n    mixSpecIntoComponent(Constructor, spec); // Initialize the defaultProps property after all mixins have been merged\n\n    if (Constructor.getDefaultProps) {\n      Constructor.defaultProps = Constructor.getDefaultProps();\n    }\n\n    \"production\" !== process.env.NODE_ENV ? invariant(Constructor.prototype.render, 'createClass(...): Class specification must implement a `render` method.') : invariant(Constructor.prototype.render);\n\n    if (\"production\" !== process.env.NODE_ENV) {\n      if (Constructor.prototype.componentShouldUpdate) {\n        monitorCodeUse('react_component_should_update_warning', {\n          component: spec.displayName\n        });\n        console.warn((spec.displayName || 'A component') + ' has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.');\n      }\n    } // Reduce time spent doing lookups by setting these on the prototype.\n\n\n    for (var methodName in ReactCompositeComponentInterface) {\n      if (!Constructor.prototype[methodName]) {\n        Constructor.prototype[methodName] = null;\n      }\n    }\n\n    if (\"production\" !== process.env.NODE_ENV) {\n      return ReactLegacyElement.wrapFactory(ReactElementValidator.createFactory(Constructor));\n    }\n\n    return ReactLegacyElement.wrapFactory(ReactElement.createFactory(Constructor));\n  },\n  injection: {\n    injectMixin: function (mixin) {\n      injectedMixins.push(mixin);\n    }\n  }\n};\nmodule.exports = ReactCompositeComponent;","map":{"version":3,"sources":["/Users/ejmaltes/Desktop/Personal-Website/node_modules/react-object-fit-cover/node_modules/react/lib/ReactCompositeComponent.js"],"names":["ReactComponent","require","ReactContext","ReactCurrentOwner","ReactElement","ReactElementValidator","ReactEmptyComponent","ReactErrorUtils","ReactLegacyElement","ReactOwner","ReactPerf","ReactPropTransferer","ReactPropTypeLocations","ReactPropTypeLocationNames","ReactUpdates","assign","instantiateReactComponent","invariant","keyMirror","keyOf","monitorCodeUse","mapObject","shouldUpdateReactComponent","warning","MIXINS_KEY","mixins","SpecPolicy","DEFINE_ONCE","DEFINE_MANY","OVERRIDE_BASE","DEFINE_MANY_MERGED","injectedMixins","ReactCompositeComponentInterface","statics","propTypes","contextTypes","childContextTypes","getDefaultProps","getInitialState","getChildContext","render","componentWillMount","componentDidMount","componentWillReceiveProps","shouldComponentUpdate","componentWillUpdate","componentDidUpdate","componentWillUnmount","updateComponent","RESERVED_SPEC_KEYS","displayName","Constructor","i","length","mixSpecIntoComponent","validateTypeDef","childContext","context","createMergedResultFunction","prop","mixStaticSpecIntoComponent","getDeclarationErrorAddendum","component","owner","_owner","constructor","typeDef","location","propName","hasOwnProperty","process","env","NODE_ENV","validateMethodOverride","proto","name","specPolicy","ReactCompositeComponentMixin","validateLifeCycleOnReplaceState","instance","compositeLifeCycleState","_compositeLifeCycleState","isMounted","CompositeLifeCycle","MOUNTING","current","UNMOUNTING","spec","isValidFactory","isValidElement","prototype","property","isCompositeComponentMethod","isAlreadyDefined","markedDontBind","__reactDontBind","isFunction","shouldAutoBind","__reactAutoBindMap","createChainedFunction","isReserved","isInherited","mergeObjectsWithNoDuplicateKeys","one","two","value","key","undefined","mergedResult","a","apply","arguments","b","chainedFunction","RECEIVING_PROPS","construct","element","Mixin","state","_pendingState","call","mountComponent","measure","rootID","transaction","mountDepth","_bindAutoBindMethods","_processContext","_currentElement","_context","props","_processProps","Array","isArray","_pendingForceUpdate","_renderedComponent","_renderValidatedComponent","type","markup","getReactMountReady","enqueue","unmountComponent","setState","partialState","callback","replaceState","completeState","enqueueUpdate","maskedContext","contextName","_checkPropTypes","_processChildContext","currentContext","newProps","componentName","error","Error","addendum","message","performUpdateIfNecessary","_pendingElement","nextContext","nextProps","nextElement","nextState","shouldUpdate","console","warn","_performComponentUpdate","prevElement","prevProps","prevState","prevContext","bind","receiveComponent","prevParentElement","prevComponentInstance","thisID","_rootNodeID","prevComponentID","nextMarkup","_mountDepth","BackendIDOperations","dangerouslyReplaceNodeWithMarkupByID","forceUpdate","renderedComponent","previousContext","getEmptyComponent","registerNullComponentID","deregisterNullComponentID","autoBindKey","method","_bindAutoBindMethod","guard","boundMethod","__reactBoundContext","__reactBoundMethod","__reactBoundArguments","_bind","newThis","args","$__0","$__1","push","reboundMethod","ReactCompositeComponentBase","ReactCompositeComponent","LifeCycle","Base","createClass","forEach","defaultProps","componentShouldUpdate","methodName","wrapFactory","createFactory","injection","injectMixin","mixin","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactCompositeComponent\n */\n\n\"use strict\";\n\nvar ReactComponent = require(\"./ReactComponent\");\nvar ReactContext = require(\"./ReactContext\");\nvar ReactCurrentOwner = require(\"./ReactCurrentOwner\");\nvar ReactElement = require(\"./ReactElement\");\nvar ReactElementValidator = require(\"./ReactElementValidator\");\nvar ReactEmptyComponent = require(\"./ReactEmptyComponent\");\nvar ReactErrorUtils = require(\"./ReactErrorUtils\");\nvar ReactLegacyElement = require(\"./ReactLegacyElement\");\nvar ReactOwner = require(\"./ReactOwner\");\nvar ReactPerf = require(\"./ReactPerf\");\nvar ReactPropTransferer = require(\"./ReactPropTransferer\");\nvar ReactPropTypeLocations = require(\"./ReactPropTypeLocations\");\nvar ReactPropTypeLocationNames = require(\"./ReactPropTypeLocationNames\");\nvar ReactUpdates = require(\"./ReactUpdates\");\n\nvar assign = require(\"./Object.assign\");\nvar instantiateReactComponent = require(\"./instantiateReactComponent\");\nvar invariant = require(\"./invariant\");\nvar keyMirror = require(\"./keyMirror\");\nvar keyOf = require(\"./keyOf\");\nvar monitorCodeUse = require(\"./monitorCodeUse\");\nvar mapObject = require(\"./mapObject\");\nvar shouldUpdateReactComponent = require(\"./shouldUpdateReactComponent\");\nvar warning = require(\"./warning\");\n\nvar MIXINS_KEY = keyOf({mixins: null});\n\n/**\n * Policies that describe methods in `ReactCompositeComponentInterface`.\n */\nvar SpecPolicy = keyMirror({\n  /**\n   * These methods may be defined only once by the class specification or mixin.\n   */\n  DEFINE_ONCE: null,\n  /**\n   * These methods may be defined by both the class specification and mixins.\n   * Subsequent definitions will be chained. These methods must return void.\n   */\n  DEFINE_MANY: null,\n  /**\n   * These methods are overriding the base ReactCompositeComponent class.\n   */\n  OVERRIDE_BASE: null,\n  /**\n   * These methods are similar to DEFINE_MANY, except we assume they return\n   * objects. We try to merge the keys of the return values of all the mixed in\n   * functions. If there is a key conflict we throw.\n   */\n  DEFINE_MANY_MERGED: null\n});\n\n\nvar injectedMixins = [];\n\n/**\n * Composite components are higher-level components that compose other composite\n * or native components.\n *\n * To create a new type of `ReactCompositeComponent`, pass a specification of\n * your new class to `React.createClass`. The only requirement of your class\n * specification is that you implement a `render` method.\n *\n *   var MyComponent = React.createClass({\n *     render: function() {\n *       return <div>Hello World</div>;\n *     }\n *   });\n *\n * The class specification supports a specific protocol of methods that have\n * special meaning (e.g. `render`). See `ReactCompositeComponentInterface` for\n * more the comprehensive protocol. Any other properties and methods in the\n * class specification will available on the prototype.\n *\n * @interface ReactCompositeComponentInterface\n * @internal\n */\nvar ReactCompositeComponentInterface = {\n\n  /**\n   * An array of Mixin objects to include when defining your component.\n   *\n   * @type {array}\n   * @optional\n   */\n  mixins: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * An object containing properties and methods that should be defined on\n   * the component's constructor instead of its prototype (static methods).\n   *\n   * @type {object}\n   * @optional\n   */\n  statics: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * Definition of prop types for this component.\n   *\n   * @type {object}\n   * @optional\n   */\n  propTypes: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * Definition of context types for this component.\n   *\n   * @type {object}\n   * @optional\n   */\n  contextTypes: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * Definition of context types this component sets for its children.\n   *\n   * @type {object}\n   * @optional\n   */\n  childContextTypes: SpecPolicy.DEFINE_MANY,\n\n  // ==== Definition methods ====\n\n  /**\n   * Invoked when the component is mounted. Values in the mapping will be set on\n   * `this.props` if that prop is not specified (i.e. using an `in` check).\n   *\n   * This method is invoked before `getInitialState` and therefore cannot rely\n   * on `this.state` or use `this.setState`.\n   *\n   * @return {object}\n   * @optional\n   */\n  getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,\n\n  /**\n   * Invoked once before the component is mounted. The return value will be used\n   * as the initial value of `this.state`.\n   *\n   *   getInitialState: function() {\n   *     return {\n   *       isOn: false,\n   *       fooBaz: new BazFoo()\n   *     }\n   *   }\n   *\n   * @return {object}\n   * @optional\n   */\n  getInitialState: SpecPolicy.DEFINE_MANY_MERGED,\n\n  /**\n   * @return {object}\n   * @optional\n   */\n  getChildContext: SpecPolicy.DEFINE_MANY_MERGED,\n\n  /**\n   * Uses props from `this.props` and state from `this.state` to render the\n   * structure of the component.\n   *\n   * No guarantees are made about when or how often this method is invoked, so\n   * it must not have side effects.\n   *\n   *   render: function() {\n   *     var name = this.props.name;\n   *     return <div>Hello, {name}!</div>;\n   *   }\n   *\n   * @return {ReactComponent}\n   * @nosideeffects\n   * @required\n   */\n  render: SpecPolicy.DEFINE_ONCE,\n\n\n\n  // ==== Delegate methods ====\n\n  /**\n   * Invoked when the component is initially created and about to be mounted.\n   * This may have side effects, but any external subscriptions or data created\n   * by this method must be cleaned up in `componentWillUnmount`.\n   *\n   * @optional\n   */\n  componentWillMount: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * Invoked when the component has been mounted and has a DOM representation.\n   * However, there is no guarantee that the DOM node is in the document.\n   *\n   * Use this as an opportunity to operate on the DOM when the component has\n   * been mounted (initialized and rendered) for the first time.\n   *\n   * @param {DOMElement} rootNode DOM element representing the component.\n   * @optional\n   */\n  componentDidMount: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * Invoked before the component receives new props.\n   *\n   * Use this as an opportunity to react to a prop transition by updating the\n   * state using `this.setState`. Current props are accessed via `this.props`.\n   *\n   *   componentWillReceiveProps: function(nextProps, nextContext) {\n   *     this.setState({\n   *       likesIncreasing: nextProps.likeCount > this.props.likeCount\n   *     });\n   *   }\n   *\n   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop\n   * transition may cause a state change, but the opposite is not true. If you\n   * need it, you are probably looking for `componentWillUpdate`.\n   *\n   * @param {object} nextProps\n   * @optional\n   */\n  componentWillReceiveProps: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * Invoked while deciding if the component should be updated as a result of\n   * receiving new props, state and/or context.\n   *\n   * Use this as an opportunity to `return false` when you're certain that the\n   * transition to the new props/state/context will not require a component\n   * update.\n   *\n   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {\n   *     return !equal(nextProps, this.props) ||\n   *       !equal(nextState, this.state) ||\n   *       !equal(nextContext, this.context);\n   *   }\n   *\n   * @param {object} nextProps\n   * @param {?object} nextState\n   * @param {?object} nextContext\n   * @return {boolean} True if the component should update.\n   * @optional\n   */\n  shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,\n\n  /**\n   * Invoked when the component is about to update due to a transition from\n   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`\n   * and `nextContext`.\n   *\n   * Use this as an opportunity to perform preparation before an update occurs.\n   *\n   * NOTE: You **cannot** use `this.setState()` in this method.\n   *\n   * @param {object} nextProps\n   * @param {?object} nextState\n   * @param {?object} nextContext\n   * @param {ReactReconcileTransaction} transaction\n   * @optional\n   */\n  componentWillUpdate: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * Invoked when the component's DOM representation has been updated.\n   *\n   * Use this as an opportunity to operate on the DOM when the component has\n   * been updated.\n   *\n   * @param {object} prevProps\n   * @param {?object} prevState\n   * @param {?object} prevContext\n   * @param {DOMElement} rootNode DOM element representing the component.\n   * @optional\n   */\n  componentDidUpdate: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * Invoked when the component is about to be removed from its parent and have\n   * its DOM representation destroyed.\n   *\n   * Use this as an opportunity to deallocate any external resources.\n   *\n   * NOTE: There is no `componentDidUnmount` since your component will have been\n   * destroyed by that point.\n   *\n   * @optional\n   */\n  componentWillUnmount: SpecPolicy.DEFINE_MANY,\n\n\n\n  // ==== Advanced methods ====\n\n  /**\n   * Updates the component's currently mounted DOM representation.\n   *\n   * By default, this implements React's rendering and reconciliation algorithm.\n   * Sophisticated clients may wish to override this.\n   *\n   * @param {ReactReconcileTransaction} transaction\n   * @internal\n   * @overridable\n   */\n  updateComponent: SpecPolicy.OVERRIDE_BASE\n\n};\n\n/**\n * Mapping from class specification keys to special processing functions.\n *\n * Although these are declared like instance properties in the specification\n * when defining classes using `React.createClass`, they are actually static\n * and are accessible on the constructor instead of the prototype. Despite\n * being static, they must be defined outside of the \"statics\" key under\n * which all other static methods are defined.\n */\nvar RESERVED_SPEC_KEYS = {\n  displayName: function(Constructor, displayName) {\n    Constructor.displayName = displayName;\n  },\n  mixins: function(Constructor, mixins) {\n    if (mixins) {\n      for (var i = 0; i < mixins.length; i++) {\n        mixSpecIntoComponent(Constructor, mixins[i]);\n      }\n    }\n  },\n  childContextTypes: function(Constructor, childContextTypes) {\n    validateTypeDef(\n      Constructor,\n      childContextTypes,\n      ReactPropTypeLocations.childContext\n    );\n    Constructor.childContextTypes = assign(\n      {},\n      Constructor.childContextTypes,\n      childContextTypes\n    );\n  },\n  contextTypes: function(Constructor, contextTypes) {\n    validateTypeDef(\n      Constructor,\n      contextTypes,\n      ReactPropTypeLocations.context\n    );\n    Constructor.contextTypes = assign(\n      {},\n      Constructor.contextTypes,\n      contextTypes\n    );\n  },\n  /**\n   * Special case getDefaultProps which should move into statics but requires\n   * automatic merging.\n   */\n  getDefaultProps: function(Constructor, getDefaultProps) {\n    if (Constructor.getDefaultProps) {\n      Constructor.getDefaultProps = createMergedResultFunction(\n        Constructor.getDefaultProps,\n        getDefaultProps\n      );\n    } else {\n      Constructor.getDefaultProps = getDefaultProps;\n    }\n  },\n  propTypes: function(Constructor, propTypes) {\n    validateTypeDef(\n      Constructor,\n      propTypes,\n      ReactPropTypeLocations.prop\n    );\n    Constructor.propTypes = assign(\n      {},\n      Constructor.propTypes,\n      propTypes\n    );\n  },\n  statics: function(Constructor, statics) {\n    mixStaticSpecIntoComponent(Constructor, statics);\n  }\n};\n\nfunction getDeclarationErrorAddendum(component) {\n  var owner = component._owner || null;\n  if (owner && owner.constructor && owner.constructor.displayName) {\n    return ' Check the render method of `' + owner.constructor.displayName +\n      '`.';\n  }\n  return '';\n}\n\nfunction validateTypeDef(Constructor, typeDef, location) {\n  for (var propName in typeDef) {\n    if (typeDef.hasOwnProperty(propName)) {\n      (\"production\" !== process.env.NODE_ENV ? invariant(\n        typeof typeDef[propName] == 'function',\n        '%s: %s type `%s` is invalid; it must be a function, usually from ' +\n        'React.PropTypes.',\n        Constructor.displayName || 'ReactCompositeComponent',\n        ReactPropTypeLocationNames[location],\n        propName\n      ) : invariant(typeof typeDef[propName] == 'function'));\n    }\n  }\n}\n\nfunction validateMethodOverride(proto, name) {\n  var specPolicy = ReactCompositeComponentInterface.hasOwnProperty(name) ?\n    ReactCompositeComponentInterface[name] :\n    null;\n\n  // Disallow overriding of base class methods unless explicitly allowed.\n  if (ReactCompositeComponentMixin.hasOwnProperty(name)) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      specPolicy === SpecPolicy.OVERRIDE_BASE,\n      'ReactCompositeComponentInterface: You are attempting to override ' +\n      '`%s` from your class specification. Ensure that your method names ' +\n      'do not overlap with React methods.',\n      name\n    ) : invariant(specPolicy === SpecPolicy.OVERRIDE_BASE));\n  }\n\n  // Disallow defining methods more than once unless explicitly allowed.\n  if (proto.hasOwnProperty(name)) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      specPolicy === SpecPolicy.DEFINE_MANY ||\n      specPolicy === SpecPolicy.DEFINE_MANY_MERGED,\n      'ReactCompositeComponentInterface: You are attempting to define ' +\n      '`%s` on your component more than once. This conflict may be due ' +\n      'to a mixin.',\n      name\n    ) : invariant(specPolicy === SpecPolicy.DEFINE_MANY ||\n    specPolicy === SpecPolicy.DEFINE_MANY_MERGED));\n  }\n}\n\nfunction validateLifeCycleOnReplaceState(instance) {\n  var compositeLifeCycleState = instance._compositeLifeCycleState;\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    instance.isMounted() ||\n      compositeLifeCycleState === CompositeLifeCycle.MOUNTING,\n    'replaceState(...): Can only update a mounted or mounting component.'\n  ) : invariant(instance.isMounted() ||\n    compositeLifeCycleState === CompositeLifeCycle.MOUNTING));\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    ReactCurrentOwner.current == null,\n    'replaceState(...): Cannot update during an existing state transition ' +\n    '(such as within `render`). Render methods should be a pure function ' +\n    'of props and state.'\n  ) : invariant(ReactCurrentOwner.current == null));\n  (\"production\" !== process.env.NODE_ENV ? invariant(compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING,\n    'replaceState(...): Cannot update while unmounting component. This ' +\n    'usually means you called setState() on an unmounted component.'\n  ) : invariant(compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING));\n}\n\n/**\n * Mixin helper which handles policy validation and reserved\n * specification keys when building `ReactCompositeComponent` classses.\n */\nfunction mixSpecIntoComponent(Constructor, spec) {\n  if (!spec) {\n    return;\n  }\n\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    !ReactLegacyElement.isValidFactory(spec),\n    'ReactCompositeComponent: You\\'re attempting to ' +\n    'use a component class as a mixin. Instead, just use a regular object.'\n  ) : invariant(!ReactLegacyElement.isValidFactory(spec)));\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    !ReactElement.isValidElement(spec),\n    'ReactCompositeComponent: You\\'re attempting to ' +\n    'use a component as a mixin. Instead, just use a regular object.'\n  ) : invariant(!ReactElement.isValidElement(spec)));\n\n  var proto = Constructor.prototype;\n\n  // By handling mixins before any other properties, we ensure the same\n  // chaining order is applied to methods with DEFINE_MANY policy, whether\n  // mixins are listed before or after these methods in the spec.\n  if (spec.hasOwnProperty(MIXINS_KEY)) {\n    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);\n  }\n\n  for (var name in spec) {\n    if (!spec.hasOwnProperty(name)) {\n      continue;\n    }\n\n    if (name === MIXINS_KEY) {\n      // We have already handled mixins in a special case above\n      continue;\n    }\n\n    var property = spec[name];\n    validateMethodOverride(proto, name);\n\n    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {\n      RESERVED_SPEC_KEYS[name](Constructor, property);\n    } else {\n      // Setup methods on prototype:\n      // The following member methods should not be automatically bound:\n      // 1. Expected ReactCompositeComponent methods (in the \"interface\").\n      // 2. Overridden methods (that were mixed in).\n      var isCompositeComponentMethod =\n        ReactCompositeComponentInterface.hasOwnProperty(name);\n      var isAlreadyDefined = proto.hasOwnProperty(name);\n      var markedDontBind = property && property.__reactDontBind;\n      var isFunction = typeof property === 'function';\n      var shouldAutoBind =\n        isFunction &&\n        !isCompositeComponentMethod &&\n        !isAlreadyDefined &&\n        !markedDontBind;\n\n      if (shouldAutoBind) {\n        if (!proto.__reactAutoBindMap) {\n          proto.__reactAutoBindMap = {};\n        }\n        proto.__reactAutoBindMap[name] = property;\n        proto[name] = property;\n      } else {\n        if (isAlreadyDefined) {\n          var specPolicy = ReactCompositeComponentInterface[name];\n\n          // These cases should already be caught by validateMethodOverride\n          (\"production\" !== process.env.NODE_ENV ? invariant(\n            isCompositeComponentMethod && (\n              specPolicy === SpecPolicy.DEFINE_MANY_MERGED ||\n              specPolicy === SpecPolicy.DEFINE_MANY\n            ),\n            'ReactCompositeComponent: Unexpected spec policy %s for key %s ' +\n            'when mixing in component specs.',\n            specPolicy,\n            name\n          ) : invariant(isCompositeComponentMethod && (\n            specPolicy === SpecPolicy.DEFINE_MANY_MERGED ||\n            specPolicy === SpecPolicy.DEFINE_MANY\n          )));\n\n          // For methods which are defined more than once, call the existing\n          // methods before calling the new property, merging if appropriate.\n          if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {\n            proto[name] = createMergedResultFunction(proto[name], property);\n          } else if (specPolicy === SpecPolicy.DEFINE_MANY) {\n            proto[name] = createChainedFunction(proto[name], property);\n          }\n        } else {\n          proto[name] = property;\n          if (\"production\" !== process.env.NODE_ENV) {\n            // Add verbose displayName to the function, which helps when looking\n            // at profiling tools.\n            if (typeof property === 'function' && spec.displayName) {\n              proto[name].displayName = spec.displayName + '_' + name;\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction mixStaticSpecIntoComponent(Constructor, statics) {\n  if (!statics) {\n    return;\n  }\n  for (var name in statics) {\n    var property = statics[name];\n    if (!statics.hasOwnProperty(name)) {\n      continue;\n    }\n\n    var isReserved = name in RESERVED_SPEC_KEYS;\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      !isReserved,\n      'ReactCompositeComponent: You are attempting to define a reserved ' +\n      'property, `%s`, that shouldn\\'t be on the \"statics\" key. Define it ' +\n      'as an instance property instead; it will still be accessible on the ' +\n      'constructor.',\n      name\n    ) : invariant(!isReserved));\n\n    var isInherited = name in Constructor;\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      !isInherited,\n      'ReactCompositeComponent: You are attempting to define ' +\n      '`%s` on your component more than once. This conflict may be ' +\n      'due to a mixin.',\n      name\n    ) : invariant(!isInherited));\n    Constructor[name] = property;\n  }\n}\n\n/**\n * Merge two objects, but throw if both contain the same key.\n *\n * @param {object} one The first object, which is mutated.\n * @param {object} two The second object\n * @return {object} one after it has been mutated to contain everything in two.\n */\nfunction mergeObjectsWithNoDuplicateKeys(one, two) {\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    one && two && typeof one === 'object' && typeof two === 'object',\n    'mergeObjectsWithNoDuplicateKeys(): Cannot merge non-objects'\n  ) : invariant(one && two && typeof one === 'object' && typeof two === 'object'));\n\n  mapObject(two, function(value, key) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      one[key] === undefined,\n      'mergeObjectsWithNoDuplicateKeys(): ' +\n      'Tried to merge two objects with the same key: `%s`. This conflict ' +\n      'may be due to a mixin; in particular, this may be caused by two ' +\n      'getInitialState() or getDefaultProps() methods returning objects ' +\n      'with clashing keys.',\n      key\n    ) : invariant(one[key] === undefined));\n    one[key] = value;\n  });\n  return one;\n}\n\n/**\n * Creates a function that invokes two functions and merges their return values.\n *\n * @param {function} one Function to invoke first.\n * @param {function} two Function to invoke second.\n * @return {function} Function that invokes the two argument functions.\n * @private\n */\nfunction createMergedResultFunction(one, two) {\n  return function mergedResult() {\n    var a = one.apply(this, arguments);\n    var b = two.apply(this, arguments);\n    if (a == null) {\n      return b;\n    } else if (b == null) {\n      return a;\n    }\n    return mergeObjectsWithNoDuplicateKeys(a, b);\n  };\n}\n\n/**\n * Creates a function that invokes two functions and ignores their return vales.\n *\n * @param {function} one Function to invoke first.\n * @param {function} two Function to invoke second.\n * @return {function} Function that invokes the two argument functions.\n * @private\n */\nfunction createChainedFunction(one, two) {\n  return function chainedFunction() {\n    one.apply(this, arguments);\n    two.apply(this, arguments);\n  };\n}\n\n/**\n * `ReactCompositeComponent` maintains an auxiliary life cycle state in\n * `this._compositeLifeCycleState` (which can be null).\n *\n * This is different from the life cycle state maintained by `ReactComponent` in\n * `this._lifeCycleState`. The following diagram shows how the states overlap in\n * time. There are times when the CompositeLifeCycle is null - at those times it\n * is only meaningful to look at ComponentLifeCycle alone.\n *\n * Top Row: ReactComponent.ComponentLifeCycle\n * Low Row: ReactComponent.CompositeLifeCycle\n *\n * +-------+---------------------------------+--------+\n * |  UN   |             MOUNTED             |   UN   |\n * |MOUNTED|                                 | MOUNTED|\n * +-------+---------------------------------+--------+\n * |       ^--------+   +-------+   +--------^        |\n * |       |        |   |       |   |        |        |\n * |    0--|MOUNTING|-0-|RECEIVE|-0-|   UN   |--->0   |\n * |       |        |   |PROPS  |   |MOUNTING|        |\n * |       |        |   |       |   |        |        |\n * |       |        |   |       |   |        |        |\n * |       +--------+   +-------+   +--------+        |\n * |       |                                 |        |\n * +-------+---------------------------------+--------+\n */\nvar CompositeLifeCycle = keyMirror({\n  /**\n   * Components in the process of being mounted respond to state changes\n   * differently.\n   */\n  MOUNTING: null,\n  /**\n   * Components in the process of being unmounted are guarded against state\n   * changes.\n   */\n  UNMOUNTING: null,\n  /**\n   * Components that are mounted and receiving new props respond to state\n   * changes differently.\n   */\n  RECEIVING_PROPS: null\n});\n\n/**\n * @lends {ReactCompositeComponent.prototype}\n */\nvar ReactCompositeComponentMixin = {\n\n  /**\n   * Base constructor for all composite component.\n   *\n   * @param {ReactElement} element\n   * @final\n   * @internal\n   */\n  construct: function(element) {\n    // Children can be either an array or more than one argument\n    ReactComponent.Mixin.construct.apply(this, arguments);\n    ReactOwner.Mixin.construct.apply(this, arguments);\n\n    this.state = null;\n    this._pendingState = null;\n\n    // This is the public post-processed context. The real context and pending\n    // context lives on the element.\n    this.context = null;\n\n    this._compositeLifeCycleState = null;\n  },\n\n  /**\n   * Checks whether or not this composite component is mounted.\n   * @return {boolean} True if mounted, false otherwise.\n   * @protected\n   * @final\n   */\n  isMounted: function() {\n    return ReactComponent.Mixin.isMounted.call(this) &&\n      this._compositeLifeCycleState !== CompositeLifeCycle.MOUNTING;\n  },\n\n  /**\n   * Initializes the component, renders markup, and registers event listeners.\n   *\n   * @param {string} rootID DOM ID of the root node.\n   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\n   * @param {number} mountDepth number of components in the owner hierarchy\n   * @return {?string} Rendered markup to be inserted into the DOM.\n   * @final\n   * @internal\n   */\n  mountComponent: ReactPerf.measure(\n    'ReactCompositeComponent',\n    'mountComponent',\n    function(rootID, transaction, mountDepth) {\n      ReactComponent.Mixin.mountComponent.call(\n        this,\n        rootID,\n        transaction,\n        mountDepth\n      );\n      this._compositeLifeCycleState = CompositeLifeCycle.MOUNTING;\n\n      if (this.__reactAutoBindMap) {\n        this._bindAutoBindMethods();\n      }\n\n      this.context = this._processContext(this._currentElement._context);\n      this.props = this._processProps(this.props);\n\n      this.state = this.getInitialState ? this.getInitialState() : null;\n      (\"production\" !== process.env.NODE_ENV ? invariant(\n        typeof this.state === 'object' && !Array.isArray(this.state),\n        '%s.getInitialState(): must return an object or null',\n        this.constructor.displayName || 'ReactCompositeComponent'\n      ) : invariant(typeof this.state === 'object' && !Array.isArray(this.state)));\n\n      this._pendingState = null;\n      this._pendingForceUpdate = false;\n\n      if (this.componentWillMount) {\n        this.componentWillMount();\n        // When mounting, calls to `setState` by `componentWillMount` will set\n        // `this._pendingState` without triggering a re-render.\n        if (this._pendingState) {\n          this.state = this._pendingState;\n          this._pendingState = null;\n        }\n      }\n\n      this._renderedComponent = instantiateReactComponent(\n        this._renderValidatedComponent(),\n        this._currentElement.type // The wrapping type\n      );\n\n      // Done with mounting, `setState` will now trigger UI changes.\n      this._compositeLifeCycleState = null;\n      var markup = this._renderedComponent.mountComponent(\n        rootID,\n        transaction,\n        mountDepth + 1\n      );\n      if (this.componentDidMount) {\n        transaction.getReactMountReady().enqueue(this.componentDidMount, this);\n      }\n      return markup;\n    }\n  ),\n\n  /**\n   * Releases any resources allocated by `mountComponent`.\n   *\n   * @final\n   * @internal\n   */\n  unmountComponent: function() {\n    this._compositeLifeCycleState = CompositeLifeCycle.UNMOUNTING;\n    if (this.componentWillUnmount) {\n      this.componentWillUnmount();\n    }\n    this._compositeLifeCycleState = null;\n\n    this._renderedComponent.unmountComponent();\n    this._renderedComponent = null;\n\n    ReactComponent.Mixin.unmountComponent.call(this);\n\n    // Some existing components rely on this.props even after they've been\n    // destroyed (in event handlers).\n    // TODO: this.props = null;\n    // TODO: this.state = null;\n  },\n\n  /**\n   * Sets a subset of the state. Always use this or `replaceState` to mutate\n   * state. You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * There is no guarantee that calls to `setState` will run synchronously,\n   * as they may eventually be batched together.  You can provide an optional\n   * callback that will be executed when the call to setState is actually\n   * completed.\n   *\n   * @param {object} partialState Next partial state to be merged with state.\n   * @param {?function} callback Called after state is updated.\n   * @final\n   * @protected\n   */\n  setState: function(partialState, callback) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      typeof partialState === 'object' || partialState == null,\n      'setState(...): takes an object of state variables to update.'\n    ) : invariant(typeof partialState === 'object' || partialState == null));\n    if (\"production\" !== process.env.NODE_ENV){\n      (\"production\" !== process.env.NODE_ENV ? warning(\n        partialState != null,\n        'setState(...): You passed an undefined or null state object; ' +\n        'instead, use forceUpdate().'\n      ) : null);\n    }\n    // Merge with `_pendingState` if it exists, otherwise with existing state.\n    this.replaceState(\n      assign({}, this._pendingState || this.state, partialState),\n      callback\n    );\n  },\n\n  /**\n   * Replaces all of the state. Always use this or `setState` to mutate state.\n   * You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * @param {object} completeState Next state.\n   * @param {?function} callback Called after state is updated.\n   * @final\n   * @protected\n   */\n  replaceState: function(completeState, callback) {\n    validateLifeCycleOnReplaceState(this);\n    this._pendingState = completeState;\n    if (this._compositeLifeCycleState !== CompositeLifeCycle.MOUNTING) {\n      // If we're in a componentWillMount handler, don't enqueue a rerender\n      // because ReactUpdates assumes we're in a browser context (which is wrong\n      // for server rendering) and we're about to do a render anyway.\n      // TODO: The callback here is ignored when setState is called from\n      // componentWillMount. Either fix it or disallow doing so completely in\n      // favor of getInitialState.\n      ReactUpdates.enqueueUpdate(this, callback);\n    }\n  },\n\n  /**\n   * Filters the context object to only contain keys specified in\n   * `contextTypes`, and asserts that they are valid.\n   *\n   * @param {object} context\n   * @return {?object}\n   * @private\n   */\n  _processContext: function(context) {\n    var maskedContext = null;\n    var contextTypes = this.constructor.contextTypes;\n    if (contextTypes) {\n      maskedContext = {};\n      for (var contextName in contextTypes) {\n        maskedContext[contextName] = context[contextName];\n      }\n      if (\"production\" !== process.env.NODE_ENV) {\n        this._checkPropTypes(\n          contextTypes,\n          maskedContext,\n          ReactPropTypeLocations.context\n        );\n      }\n    }\n    return maskedContext;\n  },\n\n  /**\n   * @param {object} currentContext\n   * @return {object}\n   * @private\n   */\n  _processChildContext: function(currentContext) {\n    var childContext = this.getChildContext && this.getChildContext();\n    var displayName = this.constructor.displayName || 'ReactCompositeComponent';\n    if (childContext) {\n      (\"production\" !== process.env.NODE_ENV ? invariant(\n        typeof this.constructor.childContextTypes === 'object',\n        '%s.getChildContext(): childContextTypes must be defined in order to ' +\n        'use getChildContext().',\n        displayName\n      ) : invariant(typeof this.constructor.childContextTypes === 'object'));\n      if (\"production\" !== process.env.NODE_ENV) {\n        this._checkPropTypes(\n          this.constructor.childContextTypes,\n          childContext,\n          ReactPropTypeLocations.childContext\n        );\n      }\n      for (var name in childContext) {\n        (\"production\" !== process.env.NODE_ENV ? invariant(\n          name in this.constructor.childContextTypes,\n          '%s.getChildContext(): key \"%s\" is not defined in childContextTypes.',\n          displayName,\n          name\n        ) : invariant(name in this.constructor.childContextTypes));\n      }\n      return assign({}, currentContext, childContext);\n    }\n    return currentContext;\n  },\n\n  /**\n   * Processes props by setting default values for unspecified props and\n   * asserting that the props are valid. Does not mutate its argument; returns\n   * a new props object with defaults merged in.\n   *\n   * @param {object} newProps\n   * @return {object}\n   * @private\n   */\n  _processProps: function(newProps) {\n    if (\"production\" !== process.env.NODE_ENV) {\n      var propTypes = this.constructor.propTypes;\n      if (propTypes) {\n        this._checkPropTypes(propTypes, newProps, ReactPropTypeLocations.prop);\n      }\n    }\n    return newProps;\n  },\n\n  /**\n   * Assert that the props are valid\n   *\n   * @param {object} propTypes Map of prop name to a ReactPropType\n   * @param {object} props\n   * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n   * @private\n   */\n  _checkPropTypes: function(propTypes, props, location) {\n    // TODO: Stop validating prop types here and only use the element\n    // validation.\n    var componentName = this.constructor.displayName;\n    for (var propName in propTypes) {\n      if (propTypes.hasOwnProperty(propName)) {\n        var error =\n          propTypes[propName](props, propName, componentName, location);\n        if (error instanceof Error) {\n          // We may want to extend this logic for similar errors in\n          // renderComponent calls, so I'm abstracting it away into\n          // a function to minimize refactoring in the future\n          var addendum = getDeclarationErrorAddendum(this);\n          (\"production\" !== process.env.NODE_ENV ? warning(false, error.message + addendum) : null);\n        }\n      }\n    }\n  },\n\n  /**\n   * If any of `_pendingElement`, `_pendingState`, or `_pendingForceUpdate`\n   * is set, update the component.\n   *\n   * @param {ReactReconcileTransaction} transaction\n   * @internal\n   */\n  performUpdateIfNecessary: function(transaction) {\n    var compositeLifeCycleState = this._compositeLifeCycleState;\n    // Do not trigger a state transition if we are in the middle of mounting or\n    // receiving props because both of those will already be doing this.\n    if (compositeLifeCycleState === CompositeLifeCycle.MOUNTING ||\n        compositeLifeCycleState === CompositeLifeCycle.RECEIVING_PROPS) {\n      return;\n    }\n\n    if (this._pendingElement == null &&\n        this._pendingState == null &&\n        !this._pendingForceUpdate) {\n      return;\n    }\n\n    var nextContext = this.context;\n    var nextProps = this.props;\n    var nextElement = this._currentElement;\n    if (this._pendingElement != null) {\n      nextElement = this._pendingElement;\n      nextContext = this._processContext(nextElement._context);\n      nextProps = this._processProps(nextElement.props);\n      this._pendingElement = null;\n\n      this._compositeLifeCycleState = CompositeLifeCycle.RECEIVING_PROPS;\n      if (this.componentWillReceiveProps) {\n        this.componentWillReceiveProps(nextProps, nextContext);\n      }\n    }\n\n    this._compositeLifeCycleState = null;\n\n    var nextState = this._pendingState || this.state;\n    this._pendingState = null;\n\n    var shouldUpdate =\n      this._pendingForceUpdate ||\n      !this.shouldComponentUpdate ||\n      this.shouldComponentUpdate(nextProps, nextState, nextContext);\n\n    if (\"production\" !== process.env.NODE_ENV) {\n      if (typeof shouldUpdate === \"undefined\") {\n        console.warn(\n          (this.constructor.displayName || 'ReactCompositeComponent') +\n          '.shouldComponentUpdate(): Returned undefined instead of a ' +\n          'boolean value. Make sure to return true or false.'\n        );\n      }\n    }\n\n    if (shouldUpdate) {\n      this._pendingForceUpdate = false;\n      // Will set `this.props`, `this.state` and `this.context`.\n      this._performComponentUpdate(\n        nextElement,\n        nextProps,\n        nextState,\n        nextContext,\n        transaction\n      );\n    } else {\n      // If it's determined that a component should not update, we still want\n      // to set props and state.\n      this._currentElement = nextElement;\n      this.props = nextProps;\n      this.state = nextState;\n      this.context = nextContext;\n\n      // Owner cannot change because shouldUpdateReactComponent doesn't allow\n      // it. TODO: Remove this._owner completely.\n      this._owner = nextElement._owner;\n    }\n  },\n\n  /**\n   * Merges new props and state, notifies delegate methods of update and\n   * performs update.\n   *\n   * @param {ReactElement} nextElement Next element\n   * @param {object} nextProps Next public object to set as properties.\n   * @param {?object} nextState Next object to set as state.\n   * @param {?object} nextContext Next public object to set as context.\n   * @param {ReactReconcileTransaction} transaction\n   * @private\n   */\n  _performComponentUpdate: function(\n    nextElement,\n    nextProps,\n    nextState,\n    nextContext,\n    transaction\n  ) {\n    var prevElement = this._currentElement;\n    var prevProps = this.props;\n    var prevState = this.state;\n    var prevContext = this.context;\n\n    if (this.componentWillUpdate) {\n      this.componentWillUpdate(nextProps, nextState, nextContext);\n    }\n\n    this._currentElement = nextElement;\n    this.props = nextProps;\n    this.state = nextState;\n    this.context = nextContext;\n\n    // Owner cannot change because shouldUpdateReactComponent doesn't allow\n    // it. TODO: Remove this._owner completely.\n    this._owner = nextElement._owner;\n\n    this.updateComponent(\n      transaction,\n      prevElement\n    );\n\n    if (this.componentDidUpdate) {\n      transaction.getReactMountReady().enqueue(\n        this.componentDidUpdate.bind(this, prevProps, prevState, prevContext),\n        this\n      );\n    }\n  },\n\n  receiveComponent: function(nextElement, transaction) {\n    if (nextElement === this._currentElement &&\n        nextElement._owner != null) {\n      // Since elements are immutable after the owner is rendered,\n      // we can do a cheap identity compare here to determine if this is a\n      // superfluous reconcile. It's possible for state to be mutable but such\n      // change should trigger an update of the owner which would recreate\n      // the element. We explicitly check for the existence of an owner since\n      // it's possible for a element created outside a composite to be\n      // deeply mutated and reused.\n      return;\n    }\n\n    ReactComponent.Mixin.receiveComponent.call(\n      this,\n      nextElement,\n      transaction\n    );\n  },\n\n  /**\n   * Updates the component's currently mounted DOM representation.\n   *\n   * By default, this implements React's rendering and reconciliation algorithm.\n   * Sophisticated clients may wish to override this.\n   *\n   * @param {ReactReconcileTransaction} transaction\n   * @param {ReactElement} prevElement\n   * @internal\n   * @overridable\n   */\n  updateComponent: ReactPerf.measure(\n    'ReactCompositeComponent',\n    'updateComponent',\n    function(transaction, prevParentElement) {\n      ReactComponent.Mixin.updateComponent.call(\n        this,\n        transaction,\n        prevParentElement\n      );\n\n      var prevComponentInstance = this._renderedComponent;\n      var prevElement = prevComponentInstance._currentElement;\n      var nextElement = this._renderValidatedComponent();\n      if (shouldUpdateReactComponent(prevElement, nextElement)) {\n        prevComponentInstance.receiveComponent(nextElement, transaction);\n      } else {\n        // These two IDs are actually the same! But nothing should rely on that.\n        var thisID = this._rootNodeID;\n        var prevComponentID = prevComponentInstance._rootNodeID;\n        prevComponentInstance.unmountComponent();\n        this._renderedComponent = instantiateReactComponent(\n          nextElement,\n          this._currentElement.type\n        );\n        var nextMarkup = this._renderedComponent.mountComponent(\n          thisID,\n          transaction,\n          this._mountDepth + 1\n        );\n        ReactComponent.BackendIDOperations.dangerouslyReplaceNodeWithMarkupByID(\n          prevComponentID,\n          nextMarkup\n        );\n      }\n    }\n  ),\n\n  /**\n   * Forces an update. This should only be invoked when it is known with\n   * certainty that we are **not** in a DOM transaction.\n   *\n   * You may want to call this when you know that some deeper aspect of the\n   * component's state has changed but `setState` was not called.\n   *\n   * This will not invoke `shouldUpdateComponent`, but it will invoke\n   * `componentWillUpdate` and `componentDidUpdate`.\n   *\n   * @param {?function} callback Called after update is complete.\n   * @final\n   * @protected\n   */\n  forceUpdate: function(callback) {\n    var compositeLifeCycleState = this._compositeLifeCycleState;\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      this.isMounted() ||\n        compositeLifeCycleState === CompositeLifeCycle.MOUNTING,\n      'forceUpdate(...): Can only force an update on mounted or mounting ' +\n        'components.'\n    ) : invariant(this.isMounted() ||\n      compositeLifeCycleState === CompositeLifeCycle.MOUNTING));\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING &&\n      ReactCurrentOwner.current == null,\n      'forceUpdate(...): Cannot force an update while unmounting component ' +\n      'or within a `render` function.'\n    ) : invariant(compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING &&\n    ReactCurrentOwner.current == null));\n    this._pendingForceUpdate = true;\n    ReactUpdates.enqueueUpdate(this, callback);\n  },\n\n  /**\n   * @private\n   */\n  _renderValidatedComponent: ReactPerf.measure(\n    'ReactCompositeComponent',\n    '_renderValidatedComponent',\n    function() {\n      var renderedComponent;\n      var previousContext = ReactContext.current;\n      ReactContext.current = this._processChildContext(\n        this._currentElement._context\n      );\n      ReactCurrentOwner.current = this;\n      try {\n        renderedComponent = this.render();\n        if (renderedComponent === null || renderedComponent === false) {\n          renderedComponent = ReactEmptyComponent.getEmptyComponent();\n          ReactEmptyComponent.registerNullComponentID(this._rootNodeID);\n        } else {\n          ReactEmptyComponent.deregisterNullComponentID(this._rootNodeID);\n        }\n      } finally {\n        ReactContext.current = previousContext;\n        ReactCurrentOwner.current = null;\n      }\n      (\"production\" !== process.env.NODE_ENV ? invariant(\n        ReactElement.isValidElement(renderedComponent),\n        '%s.render(): A valid ReactComponent must be returned. You may have ' +\n          'returned undefined, an array or some other invalid object.',\n        this.constructor.displayName || 'ReactCompositeComponent'\n      ) : invariant(ReactElement.isValidElement(renderedComponent)));\n      return renderedComponent;\n    }\n  ),\n\n  /**\n   * @private\n   */\n  _bindAutoBindMethods: function() {\n    for (var autoBindKey in this.__reactAutoBindMap) {\n      if (!this.__reactAutoBindMap.hasOwnProperty(autoBindKey)) {\n        continue;\n      }\n      var method = this.__reactAutoBindMap[autoBindKey];\n      this[autoBindKey] = this._bindAutoBindMethod(ReactErrorUtils.guard(\n        method,\n        this.constructor.displayName + '.' + autoBindKey\n      ));\n    }\n  },\n\n  /**\n   * Binds a method to the component.\n   *\n   * @param {function} method Method to be bound.\n   * @private\n   */\n  _bindAutoBindMethod: function(method) {\n    var component = this;\n    var boundMethod = method.bind(component);\n    if (\"production\" !== process.env.NODE_ENV) {\n      boundMethod.__reactBoundContext = component;\n      boundMethod.__reactBoundMethod = method;\n      boundMethod.__reactBoundArguments = null;\n      var componentName = component.constructor.displayName;\n      var _bind = boundMethod.bind;\n      boundMethod.bind = function(newThis ) {for (var args=[],$__0=1,$__1=arguments.length;$__0<$__1;$__0++) args.push(arguments[$__0]);\n        // User is trying to bind() an autobound method; we effectively will\n        // ignore the value of \"this\" that the user is trying to use, so\n        // let's warn.\n        if (newThis !== component && newThis !== null) {\n          monitorCodeUse('react_bind_warning', { component: componentName });\n          console.warn(\n            'bind(): React component methods may only be bound to the ' +\n            'component instance. See ' + componentName\n          );\n        } else if (!args.length) {\n          monitorCodeUse('react_bind_warning', { component: componentName });\n          console.warn(\n            'bind(): You are binding a component method to the component. ' +\n            'React does this for you automatically in a high-performance ' +\n            'way, so you can safely remove this call. See ' + componentName\n          );\n          return boundMethod;\n        }\n        var reboundMethod = _bind.apply(boundMethod, arguments);\n        reboundMethod.__reactBoundContext = component;\n        reboundMethod.__reactBoundMethod = method;\n        reboundMethod.__reactBoundArguments = args;\n        return reboundMethod;\n      };\n    }\n    return boundMethod;\n  }\n};\n\nvar ReactCompositeComponentBase = function() {};\nassign(\n  ReactCompositeComponentBase.prototype,\n  ReactComponent.Mixin,\n  ReactOwner.Mixin,\n  ReactPropTransferer.Mixin,\n  ReactCompositeComponentMixin\n);\n\n/**\n * Module for creating composite components.\n *\n * @class ReactCompositeComponent\n * @extends ReactComponent\n * @extends ReactOwner\n * @extends ReactPropTransferer\n */\nvar ReactCompositeComponent = {\n\n  LifeCycle: CompositeLifeCycle,\n\n  Base: ReactCompositeComponentBase,\n\n  /**\n   * Creates a composite component class given a class specification.\n   *\n   * @param {object} spec Class specification (which must define `render`).\n   * @return {function} Component constructor function.\n   * @public\n   */\n  createClass: function(spec) {\n    var Constructor = function(props) {\n      // This constructor is overridden by mocks. The argument is used\n      // by mocks to assert on what gets mounted. This will later be used\n      // by the stand-alone class implementation.\n    };\n    Constructor.prototype = new ReactCompositeComponentBase();\n    Constructor.prototype.constructor = Constructor;\n\n    injectedMixins.forEach(\n      mixSpecIntoComponent.bind(null, Constructor)\n    );\n\n    mixSpecIntoComponent(Constructor, spec);\n\n    // Initialize the defaultProps property after all mixins have been merged\n    if (Constructor.getDefaultProps) {\n      Constructor.defaultProps = Constructor.getDefaultProps();\n    }\n\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      Constructor.prototype.render,\n      'createClass(...): Class specification must implement a `render` method.'\n    ) : invariant(Constructor.prototype.render));\n\n    if (\"production\" !== process.env.NODE_ENV) {\n      if (Constructor.prototype.componentShouldUpdate) {\n        monitorCodeUse(\n          'react_component_should_update_warning',\n          { component: spec.displayName }\n        );\n        console.warn(\n          (spec.displayName || 'A component') + ' has a method called ' +\n          'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' +\n          'The name is phrased as a question because the function is ' +\n          'expected to return a value.'\n         );\n      }\n    }\n\n    // Reduce time spent doing lookups by setting these on the prototype.\n    for (var methodName in ReactCompositeComponentInterface) {\n      if (!Constructor.prototype[methodName]) {\n        Constructor.prototype[methodName] = null;\n      }\n    }\n\n    if (\"production\" !== process.env.NODE_ENV) {\n      return ReactLegacyElement.wrapFactory(\n        ReactElementValidator.createFactory(Constructor)\n      );\n    }\n    return ReactLegacyElement.wrapFactory(\n      ReactElement.createFactory(Constructor)\n    );\n  },\n\n  injection: {\n    injectMixin: function(mixin) {\n      injectedMixins.push(mixin);\n    }\n  }\n};\n\nmodule.exports = ReactCompositeComponent;\n"]},"metadata":{},"sourceType":"script"}