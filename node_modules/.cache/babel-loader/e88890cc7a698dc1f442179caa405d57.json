{"ast":null,"code":"/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule traverseAllChildren\n */\n\"use strict\";\n\nvar ReactElement = require(\"./ReactElement\");\n\nvar ReactInstanceHandles = require(\"./ReactInstanceHandles\");\n\nvar invariant = require(\"./invariant\");\n\nvar SEPARATOR = ReactInstanceHandles.SEPARATOR;\nvar SUBSEPARATOR = ':';\n/**\n * TODO: Test that:\n * 1. `mapChildren` transforms strings and numbers into `ReactTextComponent`.\n * 2. it('should fail when supplied duplicate key', function() {\n * 3. That a single child and an array with one item have the same key pattern.\n * });\n */\n\nvar userProvidedKeyEscaperLookup = {\n  '=': '=0',\n  '.': '=1',\n  ':': '=2'\n};\nvar userProvidedKeyEscapeRegex = /[=.:]/g;\n\nfunction userProvidedKeyEscaper(match) {\n  return userProvidedKeyEscaperLookup[match];\n}\n/**\n * Generate a key string that identifies a component within a set.\n *\n * @param {*} component A component that could contain a manual key.\n * @param {number} index Index that is used if a manual key is not provided.\n * @return {string}\n */\n\n\nfunction getComponentKey(component, index) {\n  if (component && component.key != null) {\n    // Explicit key\n    return wrapUserProvidedKey(component.key);\n  } // Implicit key determined by the index in the set\n\n\n  return index.toString(36);\n}\n/**\n * Escape a component key so that it is safe to use in a reactid.\n *\n * @param {*} key Component key to be escaped.\n * @return {string} An escaped string.\n */\n\n\nfunction escapeUserProvidedKey(text) {\n  return ('' + text).replace(userProvidedKeyEscapeRegex, userProvidedKeyEscaper);\n}\n/**\n * Wrap a `key` value explicitly provided by the user to distinguish it from\n * implicitly-generated keys generated by a component's index in its parent.\n *\n * @param {string} key Value of a user-provided `key` attribute\n * @return {string}\n */\n\n\nfunction wrapUserProvidedKey(key) {\n  return '$' + escapeUserProvidedKey(key);\n}\n/**\n * @param {?*} children Children tree container.\n * @param {!string} nameSoFar Name of the key path so far.\n * @param {!number} indexSoFar Number of children encountered until this point.\n * @param {!function} callback Callback to invoke with each child found.\n * @param {?*} traverseContext Used to pass information throughout the traversal\n * process.\n * @return {!number} The number of children in this subtree.\n */\n\n\nvar traverseAllChildrenImpl = function (children, nameSoFar, indexSoFar, callback, traverseContext) {\n  var nextName, nextIndex;\n  var subtreeCount = 0; // Count of children found in the current subtree.\n\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      var child = children[i];\n      nextName = nameSoFar + (nameSoFar ? SUBSEPARATOR : SEPARATOR) + getComponentKey(child, i);\n      nextIndex = indexSoFar + subtreeCount;\n      subtreeCount += traverseAllChildrenImpl(child, nextName, nextIndex, callback, traverseContext);\n    }\n  } else {\n    var type = typeof children;\n    var isOnlyChild = nameSoFar === ''; // If it's the only child, treat the name as if it was wrapped in an array\n    // so that it's consistent if the number of children grows\n\n    var storageName = isOnlyChild ? SEPARATOR + getComponentKey(children, 0) : nameSoFar;\n\n    if (children == null || type === 'boolean') {\n      // All of the above are perceived as null.\n      callback(traverseContext, null, storageName, indexSoFar);\n      subtreeCount = 1;\n    } else if (type === 'string' || type === 'number' || ReactElement.isValidElement(children)) {\n      callback(traverseContext, children, storageName, indexSoFar);\n      subtreeCount = 1;\n    } else if (type === 'object') {\n      \"production\" !== process.env.NODE_ENV ? invariant(!children || children.nodeType !== 1, 'traverseAllChildren(...): Encountered an invalid child; DOM ' + 'elements are not valid children of React components.') : invariant(!children || children.nodeType !== 1);\n\n      for (var key in children) {\n        if (children.hasOwnProperty(key)) {\n          nextName = nameSoFar + (nameSoFar ? SUBSEPARATOR : SEPARATOR) + wrapUserProvidedKey(key) + SUBSEPARATOR + getComponentKey(children[key], 0);\n          nextIndex = indexSoFar + subtreeCount;\n          subtreeCount += traverseAllChildrenImpl(children[key], nextName, nextIndex, callback, traverseContext);\n        }\n      }\n    }\n  }\n\n  return subtreeCount;\n};\n/**\n * Traverses children that are typically specified as `props.children`, but\n * might also be specified through attributes:\n *\n * - `traverseAllChildren(this.props.children, ...)`\n * - `traverseAllChildren(this.props.leftPanelChildren, ...)`\n *\n * The `traverseContext` is an optional argument that is passed through the\n * entire traversal. It can be used to store accumulations or anything else that\n * the callback might find relevant.\n *\n * @param {?*} children Children tree object.\n * @param {!function} callback To invoke upon traversing each child.\n * @param {?*} traverseContext Context for traversal.\n * @return {!number} The number of children in this subtree.\n */\n\n\nfunction traverseAllChildren(children, callback, traverseContext) {\n  if (children == null) {\n    return 0;\n  }\n\n  return traverseAllChildrenImpl(children, '', 0, callback, traverseContext);\n}\n\nmodule.exports = traverseAllChildren;","map":{"version":3,"sources":["/Users/ejmaltes/Desktop/Personal-Website/node_modules/react-object-fit-cover/node_modules/react/lib/traverseAllChildren.js"],"names":["ReactElement","require","ReactInstanceHandles","invariant","SEPARATOR","SUBSEPARATOR","userProvidedKeyEscaperLookup","userProvidedKeyEscapeRegex","userProvidedKeyEscaper","match","getComponentKey","component","index","key","wrapUserProvidedKey","toString","escapeUserProvidedKey","text","replace","traverseAllChildrenImpl","children","nameSoFar","indexSoFar","callback","traverseContext","nextName","nextIndex","subtreeCount","Array","isArray","i","length","child","type","isOnlyChild","storageName","isValidElement","process","env","NODE_ENV","nodeType","hasOwnProperty","traverseAllChildren","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule traverseAllChildren\n */\n\n\"use strict\";\n\nvar ReactElement = require(\"./ReactElement\");\nvar ReactInstanceHandles = require(\"./ReactInstanceHandles\");\n\nvar invariant = require(\"./invariant\");\n\nvar SEPARATOR = ReactInstanceHandles.SEPARATOR;\nvar SUBSEPARATOR = ':';\n\n/**\n * TODO: Test that:\n * 1. `mapChildren` transforms strings and numbers into `ReactTextComponent`.\n * 2. it('should fail when supplied duplicate key', function() {\n * 3. That a single child and an array with one item have the same key pattern.\n * });\n */\n\nvar userProvidedKeyEscaperLookup = {\n  '=': '=0',\n  '.': '=1',\n  ':': '=2'\n};\n\nvar userProvidedKeyEscapeRegex = /[=.:]/g;\n\nfunction userProvidedKeyEscaper(match) {\n  return userProvidedKeyEscaperLookup[match];\n}\n\n/**\n * Generate a key string that identifies a component within a set.\n *\n * @param {*} component A component that could contain a manual key.\n * @param {number} index Index that is used if a manual key is not provided.\n * @return {string}\n */\nfunction getComponentKey(component, index) {\n  if (component && component.key != null) {\n    // Explicit key\n    return wrapUserProvidedKey(component.key);\n  }\n  // Implicit key determined by the index in the set\n  return index.toString(36);\n}\n\n/**\n * Escape a component key so that it is safe to use in a reactid.\n *\n * @param {*} key Component key to be escaped.\n * @return {string} An escaped string.\n */\nfunction escapeUserProvidedKey(text) {\n  return ('' + text).replace(\n    userProvidedKeyEscapeRegex,\n    userProvidedKeyEscaper\n  );\n}\n\n/**\n * Wrap a `key` value explicitly provided by the user to distinguish it from\n * implicitly-generated keys generated by a component's index in its parent.\n *\n * @param {string} key Value of a user-provided `key` attribute\n * @return {string}\n */\nfunction wrapUserProvidedKey(key) {\n  return '$' + escapeUserProvidedKey(key);\n}\n\n/**\n * @param {?*} children Children tree container.\n * @param {!string} nameSoFar Name of the key path so far.\n * @param {!number} indexSoFar Number of children encountered until this point.\n * @param {!function} callback Callback to invoke with each child found.\n * @param {?*} traverseContext Used to pass information throughout the traversal\n * process.\n * @return {!number} The number of children in this subtree.\n */\nvar traverseAllChildrenImpl =\n  function(children, nameSoFar, indexSoFar, callback, traverseContext) {\n    var nextName, nextIndex;\n    var subtreeCount = 0;  // Count of children found in the current subtree.\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i];\n        nextName = (\n          nameSoFar +\n          (nameSoFar ? SUBSEPARATOR : SEPARATOR) +\n          getComponentKey(child, i)\n        );\n        nextIndex = indexSoFar + subtreeCount;\n        subtreeCount += traverseAllChildrenImpl(\n          child,\n          nextName,\n          nextIndex,\n          callback,\n          traverseContext\n        );\n      }\n    } else {\n      var type = typeof children;\n      var isOnlyChild = nameSoFar === '';\n      // If it's the only child, treat the name as if it was wrapped in an array\n      // so that it's consistent if the number of children grows\n      var storageName =\n        isOnlyChild ? SEPARATOR + getComponentKey(children, 0) : nameSoFar;\n      if (children == null || type === 'boolean') {\n        // All of the above are perceived as null.\n        callback(traverseContext, null, storageName, indexSoFar);\n        subtreeCount = 1;\n      } else if (type === 'string' || type === 'number' ||\n                 ReactElement.isValidElement(children)) {\n        callback(traverseContext, children, storageName, indexSoFar);\n        subtreeCount = 1;\n      } else if (type === 'object') {\n        (\"production\" !== process.env.NODE_ENV ? invariant(\n          !children || children.nodeType !== 1,\n          'traverseAllChildren(...): Encountered an invalid child; DOM ' +\n          'elements are not valid children of React components.'\n        ) : invariant(!children || children.nodeType !== 1));\n        for (var key in children) {\n          if (children.hasOwnProperty(key)) {\n            nextName = (\n              nameSoFar + (nameSoFar ? SUBSEPARATOR : SEPARATOR) +\n              wrapUserProvidedKey(key) + SUBSEPARATOR +\n              getComponentKey(children[key], 0)\n            );\n            nextIndex = indexSoFar + subtreeCount;\n            subtreeCount += traverseAllChildrenImpl(\n              children[key],\n              nextName,\n              nextIndex,\n              callback,\n              traverseContext\n            );\n          }\n        }\n      }\n    }\n    return subtreeCount;\n  };\n\n/**\n * Traverses children that are typically specified as `props.children`, but\n * might also be specified through attributes:\n *\n * - `traverseAllChildren(this.props.children, ...)`\n * - `traverseAllChildren(this.props.leftPanelChildren, ...)`\n *\n * The `traverseContext` is an optional argument that is passed through the\n * entire traversal. It can be used to store accumulations or anything else that\n * the callback might find relevant.\n *\n * @param {?*} children Children tree object.\n * @param {!function} callback To invoke upon traversing each child.\n * @param {?*} traverseContext Context for traversal.\n * @return {!number} The number of children in this subtree.\n */\nfunction traverseAllChildren(children, callback, traverseContext) {\n  if (children == null) {\n    return 0;\n  }\n\n  return traverseAllChildrenImpl(children, '', 0, callback, traverseContext);\n}\n\nmodule.exports = traverseAllChildren;\n"]},"metadata":{},"sourceType":"script"}