{"ast":null,"code":"/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule DOMChildrenOperations\n * @typechecks static-only\n */\n\"use strict\";\n\nvar Danger = require(\"./Danger\");\n\nvar ReactMultiChildUpdateTypes = require(\"./ReactMultiChildUpdateTypes\");\n\nvar getTextContentAccessor = require(\"./getTextContentAccessor\");\n\nvar invariant = require(\"./invariant\");\n/**\n * The DOM property to use when setting text content.\n *\n * @type {string}\n * @private\n */\n\n\nvar textContentAccessor = getTextContentAccessor();\n/**\n * Inserts `childNode` as a child of `parentNode` at the `index`.\n *\n * @param {DOMElement} parentNode Parent node in which to insert.\n * @param {DOMElement} childNode Child node to insert.\n * @param {number} index Index at which to insert the child.\n * @internal\n */\n\nfunction insertChildAt(parentNode, childNode, index) {\n  // By exploiting arrays returning `undefined` for an undefined index, we can\n  // rely exclusively on `insertBefore(node, null)` instead of also using\n  // `appendChild(node)`. However, using `undefined` is not allowed by all\n  // browsers so we must replace it with `null`.\n  parentNode.insertBefore(childNode, parentNode.childNodes[index] || null);\n}\n\nvar updateTextContent;\n\nif (textContentAccessor === 'textContent') {\n  /**\n   * Sets the text content of `node` to `text`.\n   *\n   * @param {DOMElement} node Node to change\n   * @param {string} text New text content\n   */\n  updateTextContent = function (node, text) {\n    node.textContent = text;\n  };\n} else {\n  /**\n   * Sets the text content of `node` to `text`.\n   *\n   * @param {DOMElement} node Node to change\n   * @param {string} text New text content\n   */\n  updateTextContent = function (node, text) {\n    // In order to preserve newlines correctly, we can't use .innerText to set\n    // the contents (see #1080), so we empty the element then append a text node\n    while (node.firstChild) {\n      node.removeChild(node.firstChild);\n    }\n\n    if (text) {\n      var doc = node.ownerDocument || document;\n      node.appendChild(doc.createTextNode(text));\n    }\n  };\n}\n/**\n * Operations for updating with DOM children.\n */\n\n\nvar DOMChildrenOperations = {\n  dangerouslyReplaceNodeWithMarkup: Danger.dangerouslyReplaceNodeWithMarkup,\n  updateTextContent: updateTextContent,\n\n  /**\n   * Updates a component's children by processing a series of updates. The\n   * update configurations are each expected to have a `parentNode` property.\n   *\n   * @param {array<object>} updates List of update configurations.\n   * @param {array<string>} markupList List of markup strings.\n   * @internal\n   */\n  processUpdates: function (updates, markupList) {\n    var update; // Mapping from parent IDs to initial child orderings.\n\n    var initialChildren = null; // List of children that will be moved or removed.\n\n    var updatedChildren = null;\n\n    for (var i = 0; update = updates[i]; i++) {\n      if (update.type === ReactMultiChildUpdateTypes.MOVE_EXISTING || update.type === ReactMultiChildUpdateTypes.REMOVE_NODE) {\n        var updatedIndex = update.fromIndex;\n        var updatedChild = update.parentNode.childNodes[updatedIndex];\n        var parentID = update.parentID;\n        \"production\" !== process.env.NODE_ENV ? invariant(updatedChild, 'processUpdates(): Unable to find child %s of element. This ' + 'probably means the DOM was unexpectedly mutated (e.g., by the ' + 'browser), usually due to forgetting a <tbody> when using tables, ' + 'nesting tags like <form>, <p>, or <a>, or using non-SVG elements ' + 'in an <svg> parent. Try inspecting the child nodes of the element ' + 'with React ID `%s`.', updatedIndex, parentID) : invariant(updatedChild);\n        initialChildren = initialChildren || {};\n        initialChildren[parentID] = initialChildren[parentID] || [];\n        initialChildren[parentID][updatedIndex] = updatedChild;\n        updatedChildren = updatedChildren || [];\n        updatedChildren.push(updatedChild);\n      }\n    }\n\n    var renderedMarkup = Danger.dangerouslyRenderMarkup(markupList); // Remove updated children first so that `toIndex` is consistent.\n\n    if (updatedChildren) {\n      for (var j = 0; j < updatedChildren.length; j++) {\n        updatedChildren[j].parentNode.removeChild(updatedChildren[j]);\n      }\n    }\n\n    for (var k = 0; update = updates[k]; k++) {\n      switch (update.type) {\n        case ReactMultiChildUpdateTypes.INSERT_MARKUP:\n          insertChildAt(update.parentNode, renderedMarkup[update.markupIndex], update.toIndex);\n          break;\n\n        case ReactMultiChildUpdateTypes.MOVE_EXISTING:\n          insertChildAt(update.parentNode, initialChildren[update.parentID][update.fromIndex], update.toIndex);\n          break;\n\n        case ReactMultiChildUpdateTypes.TEXT_CONTENT:\n          updateTextContent(update.parentNode, update.textContent);\n          break;\n\n        case ReactMultiChildUpdateTypes.REMOVE_NODE:\n          // Already removed by the for-loop above.\n          break;\n      }\n    }\n  }\n};\nmodule.exports = DOMChildrenOperations;","map":{"version":3,"sources":["/Users/ejmaltes/Desktop/Personal-Website/node_modules/react-object-fit-cover/node_modules/react/lib/DOMChildrenOperations.js"],"names":["Danger","require","ReactMultiChildUpdateTypes","getTextContentAccessor","invariant","textContentAccessor","insertChildAt","parentNode","childNode","index","insertBefore","childNodes","updateTextContent","node","text","textContent","firstChild","removeChild","doc","ownerDocument","document","appendChild","createTextNode","DOMChildrenOperations","dangerouslyReplaceNodeWithMarkup","processUpdates","updates","markupList","update","initialChildren","updatedChildren","i","type","MOVE_EXISTING","REMOVE_NODE","updatedIndex","fromIndex","updatedChild","parentID","process","env","NODE_ENV","push","renderedMarkup","dangerouslyRenderMarkup","j","length","k","INSERT_MARKUP","markupIndex","toIndex","TEXT_CONTENT","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule DOMChildrenOperations\n * @typechecks static-only\n */\n\n\"use strict\";\n\nvar Danger = require(\"./Danger\");\nvar ReactMultiChildUpdateTypes = require(\"./ReactMultiChildUpdateTypes\");\n\nvar getTextContentAccessor = require(\"./getTextContentAccessor\");\nvar invariant = require(\"./invariant\");\n\n/**\n * The DOM property to use when setting text content.\n *\n * @type {string}\n * @private\n */\nvar textContentAccessor = getTextContentAccessor();\n\n/**\n * Inserts `childNode` as a child of `parentNode` at the `index`.\n *\n * @param {DOMElement} parentNode Parent node in which to insert.\n * @param {DOMElement} childNode Child node to insert.\n * @param {number} index Index at which to insert the child.\n * @internal\n */\nfunction insertChildAt(parentNode, childNode, index) {\n  // By exploiting arrays returning `undefined` for an undefined index, we can\n  // rely exclusively on `insertBefore(node, null)` instead of also using\n  // `appendChild(node)`. However, using `undefined` is not allowed by all\n  // browsers so we must replace it with `null`.\n  parentNode.insertBefore(\n    childNode,\n    parentNode.childNodes[index] || null\n  );\n}\n\nvar updateTextContent;\nif (textContentAccessor === 'textContent') {\n  /**\n   * Sets the text content of `node` to `text`.\n   *\n   * @param {DOMElement} node Node to change\n   * @param {string} text New text content\n   */\n  updateTextContent = function(node, text) {\n    node.textContent = text;\n  };\n} else {\n  /**\n   * Sets the text content of `node` to `text`.\n   *\n   * @param {DOMElement} node Node to change\n   * @param {string} text New text content\n   */\n  updateTextContent = function(node, text) {\n    // In order to preserve newlines correctly, we can't use .innerText to set\n    // the contents (see #1080), so we empty the element then append a text node\n    while (node.firstChild) {\n      node.removeChild(node.firstChild);\n    }\n    if (text) {\n      var doc = node.ownerDocument || document;\n      node.appendChild(doc.createTextNode(text));\n    }\n  };\n}\n\n/**\n * Operations for updating with DOM children.\n */\nvar DOMChildrenOperations = {\n\n  dangerouslyReplaceNodeWithMarkup: Danger.dangerouslyReplaceNodeWithMarkup,\n\n  updateTextContent: updateTextContent,\n\n  /**\n   * Updates a component's children by processing a series of updates. The\n   * update configurations are each expected to have a `parentNode` property.\n   *\n   * @param {array<object>} updates List of update configurations.\n   * @param {array<string>} markupList List of markup strings.\n   * @internal\n   */\n  processUpdates: function(updates, markupList) {\n    var update;\n    // Mapping from parent IDs to initial child orderings.\n    var initialChildren = null;\n    // List of children that will be moved or removed.\n    var updatedChildren = null;\n\n    for (var i = 0; update = updates[i]; i++) {\n      if (update.type === ReactMultiChildUpdateTypes.MOVE_EXISTING ||\n          update.type === ReactMultiChildUpdateTypes.REMOVE_NODE) {\n        var updatedIndex = update.fromIndex;\n        var updatedChild = update.parentNode.childNodes[updatedIndex];\n        var parentID = update.parentID;\n\n        (\"production\" !== process.env.NODE_ENV ? invariant(\n          updatedChild,\n          'processUpdates(): Unable to find child %s of element. This ' +\n          'probably means the DOM was unexpectedly mutated (e.g., by the ' +\n          'browser), usually due to forgetting a <tbody> when using tables, ' +\n          'nesting tags like <form>, <p>, or <a>, or using non-SVG elements '+\n          'in an <svg> parent. Try inspecting the child nodes of the element ' +\n          'with React ID `%s`.',\n          updatedIndex,\n          parentID\n        ) : invariant(updatedChild));\n\n        initialChildren = initialChildren || {};\n        initialChildren[parentID] = initialChildren[parentID] || [];\n        initialChildren[parentID][updatedIndex] = updatedChild;\n\n        updatedChildren = updatedChildren || [];\n        updatedChildren.push(updatedChild);\n      }\n    }\n\n    var renderedMarkup = Danger.dangerouslyRenderMarkup(markupList);\n\n    // Remove updated children first so that `toIndex` is consistent.\n    if (updatedChildren) {\n      for (var j = 0; j < updatedChildren.length; j++) {\n        updatedChildren[j].parentNode.removeChild(updatedChildren[j]);\n      }\n    }\n\n    for (var k = 0; update = updates[k]; k++) {\n      switch (update.type) {\n        case ReactMultiChildUpdateTypes.INSERT_MARKUP:\n          insertChildAt(\n            update.parentNode,\n            renderedMarkup[update.markupIndex],\n            update.toIndex\n          );\n          break;\n        case ReactMultiChildUpdateTypes.MOVE_EXISTING:\n          insertChildAt(\n            update.parentNode,\n            initialChildren[update.parentID][update.fromIndex],\n            update.toIndex\n          );\n          break;\n        case ReactMultiChildUpdateTypes.TEXT_CONTENT:\n          updateTextContent(\n            update.parentNode,\n            update.textContent\n          );\n          break;\n        case ReactMultiChildUpdateTypes.REMOVE_NODE:\n          // Already removed by the for-loop above.\n          break;\n      }\n    }\n  }\n\n};\n\nmodule.exports = DOMChildrenOperations;\n"]},"metadata":{},"sourceType":"script"}