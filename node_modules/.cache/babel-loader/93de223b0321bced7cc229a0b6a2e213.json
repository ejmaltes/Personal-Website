{"ast":null,"code":"/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactTransitionGroup\n */\n\"use strict\";\n\nvar React = require(\"./React\");\n\nvar ReactTransitionChildMapping = require(\"./ReactTransitionChildMapping\");\n\nvar assign = require(\"./Object.assign\");\n\nvar cloneWithProps = require(\"./cloneWithProps\");\n\nvar emptyFunction = require(\"./emptyFunction\");\n\nvar ReactTransitionGroup = React.createClass({\n  displayName: 'ReactTransitionGroup',\n  propTypes: {\n    component: React.PropTypes.any,\n    childFactory: React.PropTypes.func\n  },\n  getDefaultProps: function () {\n    return {\n      component: 'span',\n      childFactory: emptyFunction.thatReturnsArgument\n    };\n  },\n  getInitialState: function () {\n    return {\n      children: ReactTransitionChildMapping.getChildMapping(this.props.children)\n    };\n  },\n  componentWillReceiveProps: function (nextProps) {\n    var nextChildMapping = ReactTransitionChildMapping.getChildMapping(nextProps.children);\n    var prevChildMapping = this.state.children;\n    this.setState({\n      children: ReactTransitionChildMapping.mergeChildMappings(prevChildMapping, nextChildMapping)\n    });\n    var key;\n\n    for (key in nextChildMapping) {\n      var hasPrev = prevChildMapping && prevChildMapping.hasOwnProperty(key);\n\n      if (nextChildMapping[key] && !hasPrev && !this.currentlyTransitioningKeys[key]) {\n        this.keysToEnter.push(key);\n      }\n    }\n\n    for (key in prevChildMapping) {\n      var hasNext = nextChildMapping && nextChildMapping.hasOwnProperty(key);\n\n      if (prevChildMapping[key] && !hasNext && !this.currentlyTransitioningKeys[key]) {\n        this.keysToLeave.push(key);\n      }\n    } // If we want to someday check for reordering, we could do it here.\n\n  },\n  componentWillMount: function () {\n    this.currentlyTransitioningKeys = {};\n    this.keysToEnter = [];\n    this.keysToLeave = [];\n  },\n  componentDidUpdate: function () {\n    var keysToEnter = this.keysToEnter;\n    this.keysToEnter = [];\n    keysToEnter.forEach(this.performEnter);\n    var keysToLeave = this.keysToLeave;\n    this.keysToLeave = [];\n    keysToLeave.forEach(this.performLeave);\n  },\n  performEnter: function (key) {\n    this.currentlyTransitioningKeys[key] = true;\n    var component = this.refs[key];\n\n    if (component.componentWillEnter) {\n      component.componentWillEnter(this._handleDoneEntering.bind(this, key));\n    } else {\n      this._handleDoneEntering(key);\n    }\n  },\n  _handleDoneEntering: function (key) {\n    var component = this.refs[key];\n\n    if (component.componentDidEnter) {\n      component.componentDidEnter();\n    }\n\n    delete this.currentlyTransitioningKeys[key];\n    var currentChildMapping = ReactTransitionChildMapping.getChildMapping(this.props.children);\n\n    if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {\n      // This was removed before it had fully entered. Remove it.\n      this.performLeave(key);\n    }\n  },\n  performLeave: function (key) {\n    this.currentlyTransitioningKeys[key] = true;\n    var component = this.refs[key];\n\n    if (component.componentWillLeave) {\n      component.componentWillLeave(this._handleDoneLeaving.bind(this, key));\n    } else {\n      // Note that this is somewhat dangerous b/c it calls setState()\n      // again, effectively mutating the component before all the work\n      // is done.\n      this._handleDoneLeaving(key);\n    }\n  },\n  _handleDoneLeaving: function (key) {\n    var component = this.refs[key];\n\n    if (component.componentDidLeave) {\n      component.componentDidLeave();\n    }\n\n    delete this.currentlyTransitioningKeys[key];\n    var currentChildMapping = ReactTransitionChildMapping.getChildMapping(this.props.children);\n\n    if (currentChildMapping && currentChildMapping.hasOwnProperty(key)) {\n      // This entered again before it fully left. Add it again.\n      this.performEnter(key);\n    } else {\n      var newChildren = assign({}, this.state.children);\n      delete newChildren[key];\n      this.setState({\n        children: newChildren\n      });\n    }\n  },\n  render: function () {\n    // TODO: we could get rid of the need for the wrapper node\n    // by cloning a single child\n    var childrenToRender = {};\n\n    for (var key in this.state.children) {\n      var child = this.state.children[key];\n\n      if (child) {\n        // You may need to apply reactive updates to a child as it is leaving.\n        // The normal React way to do it won't work since the child will have\n        // already been removed. In case you need this behavior you can provide\n        // a childFactory function to wrap every child, even the ones that are\n        // leaving.\n        childrenToRender[key] = cloneWithProps(this.props.childFactory(child), {\n          ref: key\n        });\n      }\n    }\n\n    return React.createElement(this.props.component, this.props, childrenToRender);\n  }\n});\nmodule.exports = ReactTransitionGroup;","map":{"version":3,"sources":["/Users/ejmaltes/Desktop/Personal-Website/node_modules/react-object-fit-cover/node_modules/react/lib/ReactTransitionGroup.js"],"names":["React","require","ReactTransitionChildMapping","assign","cloneWithProps","emptyFunction","ReactTransitionGroup","createClass","displayName","propTypes","component","PropTypes","any","childFactory","func","getDefaultProps","thatReturnsArgument","getInitialState","children","getChildMapping","props","componentWillReceiveProps","nextProps","nextChildMapping","prevChildMapping","state","setState","mergeChildMappings","key","hasPrev","hasOwnProperty","currentlyTransitioningKeys","keysToEnter","push","hasNext","keysToLeave","componentWillMount","componentDidUpdate","forEach","performEnter","performLeave","refs","componentWillEnter","_handleDoneEntering","bind","componentDidEnter","currentChildMapping","componentWillLeave","_handleDoneLeaving","componentDidLeave","newChildren","render","childrenToRender","child","ref","createElement","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactTransitionGroup\n */\n\n\"use strict\";\n\nvar React = require(\"./React\");\nvar ReactTransitionChildMapping = require(\"./ReactTransitionChildMapping\");\n\nvar assign = require(\"./Object.assign\");\nvar cloneWithProps = require(\"./cloneWithProps\");\nvar emptyFunction = require(\"./emptyFunction\");\n\nvar ReactTransitionGroup = React.createClass({\n  displayName: 'ReactTransitionGroup',\n\n  propTypes: {\n    component: React.PropTypes.any,\n    childFactory: React.PropTypes.func\n  },\n\n  getDefaultProps: function() {\n    return {\n      component: 'span',\n      childFactory: emptyFunction.thatReturnsArgument\n    };\n  },\n\n  getInitialState: function() {\n    return {\n      children: ReactTransitionChildMapping.getChildMapping(this.props.children)\n    };\n  },\n\n  componentWillReceiveProps: function(nextProps) {\n    var nextChildMapping = ReactTransitionChildMapping.getChildMapping(\n      nextProps.children\n    );\n    var prevChildMapping = this.state.children;\n\n    this.setState({\n      children: ReactTransitionChildMapping.mergeChildMappings(\n        prevChildMapping,\n        nextChildMapping\n      )\n    });\n\n    var key;\n\n    for (key in nextChildMapping) {\n      var hasPrev = prevChildMapping && prevChildMapping.hasOwnProperty(key);\n      if (nextChildMapping[key] && !hasPrev &&\n          !this.currentlyTransitioningKeys[key]) {\n        this.keysToEnter.push(key);\n      }\n    }\n\n    for (key in prevChildMapping) {\n      var hasNext = nextChildMapping && nextChildMapping.hasOwnProperty(key);\n      if (prevChildMapping[key] && !hasNext &&\n          !this.currentlyTransitioningKeys[key]) {\n        this.keysToLeave.push(key);\n      }\n    }\n\n    // If we want to someday check for reordering, we could do it here.\n  },\n\n  componentWillMount: function() {\n    this.currentlyTransitioningKeys = {};\n    this.keysToEnter = [];\n    this.keysToLeave = [];\n  },\n\n  componentDidUpdate: function() {\n    var keysToEnter = this.keysToEnter;\n    this.keysToEnter = [];\n    keysToEnter.forEach(this.performEnter);\n\n    var keysToLeave = this.keysToLeave;\n    this.keysToLeave = [];\n    keysToLeave.forEach(this.performLeave);\n  },\n\n  performEnter: function(key) {\n    this.currentlyTransitioningKeys[key] = true;\n\n    var component = this.refs[key];\n\n    if (component.componentWillEnter) {\n      component.componentWillEnter(\n        this._handleDoneEntering.bind(this, key)\n      );\n    } else {\n      this._handleDoneEntering(key);\n    }\n  },\n\n  _handleDoneEntering: function(key) {\n    var component = this.refs[key];\n    if (component.componentDidEnter) {\n      component.componentDidEnter();\n    }\n\n    delete this.currentlyTransitioningKeys[key];\n\n    var currentChildMapping = ReactTransitionChildMapping.getChildMapping(\n      this.props.children\n    );\n\n    if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {\n      // This was removed before it had fully entered. Remove it.\n      this.performLeave(key);\n    }\n  },\n\n  performLeave: function(key) {\n    this.currentlyTransitioningKeys[key] = true;\n\n    var component = this.refs[key];\n    if (component.componentWillLeave) {\n      component.componentWillLeave(this._handleDoneLeaving.bind(this, key));\n    } else {\n      // Note that this is somewhat dangerous b/c it calls setState()\n      // again, effectively mutating the component before all the work\n      // is done.\n      this._handleDoneLeaving(key);\n    }\n  },\n\n  _handleDoneLeaving: function(key) {\n    var component = this.refs[key];\n\n    if (component.componentDidLeave) {\n      component.componentDidLeave();\n    }\n\n    delete this.currentlyTransitioningKeys[key];\n\n    var currentChildMapping = ReactTransitionChildMapping.getChildMapping(\n      this.props.children\n    );\n\n    if (currentChildMapping && currentChildMapping.hasOwnProperty(key)) {\n      // This entered again before it fully left. Add it again.\n      this.performEnter(key);\n    } else {\n      var newChildren = assign({}, this.state.children);\n      delete newChildren[key];\n      this.setState({children: newChildren});\n    }\n  },\n\n  render: function() {\n    // TODO: we could get rid of the need for the wrapper node\n    // by cloning a single child\n    var childrenToRender = {};\n    for (var key in this.state.children) {\n      var child = this.state.children[key];\n      if (child) {\n        // You may need to apply reactive updates to a child as it is leaving.\n        // The normal React way to do it won't work since the child will have\n        // already been removed. In case you need this behavior you can provide\n        // a childFactory function to wrap every child, even the ones that are\n        // leaving.\n        childrenToRender[key] = cloneWithProps(\n          this.props.childFactory(child),\n          {ref: key}\n        );\n      }\n    }\n    return React.createElement(\n      this.props.component,\n      this.props,\n      childrenToRender\n    );\n  }\n});\n\nmodule.exports = ReactTransitionGroup;\n"]},"metadata":{},"sourceType":"script"}