{"ast":null,"code":"/**\n * Copyright 2013 Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule BeforeInputEventPlugin\n * @typechecks static-only\n */\n\"use strict\";\n\nvar EventConstants = require(\"./EventConstants\");\n\nvar EventPropagators = require(\"./EventPropagators\");\n\nvar ExecutionEnvironment = require(\"./ExecutionEnvironment\");\n\nvar SyntheticInputEvent = require(\"./SyntheticInputEvent\");\n\nvar keyOf = require(\"./keyOf\");\n\nvar canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !('documentMode' in document || isPresto());\n/**\n * Opera <= 12 includes TextEvent in window, but does not fire\n * text input events. Rely on keypress instead.\n */\n\nfunction isPresto() {\n  var opera = window.opera;\n  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;\n}\n\nvar SPACEBAR_CODE = 32;\nvar SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);\nvar topLevelTypes = EventConstants.topLevelTypes; // Events and their corresponding property names.\n\nvar eventTypes = {\n  beforeInput: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({\n        onBeforeInput: null\n      }),\n      captured: keyOf({\n        onBeforeInputCapture: null\n      })\n    },\n    dependencies: [topLevelTypes.topCompositionEnd, topLevelTypes.topKeyPress, topLevelTypes.topTextInput, topLevelTypes.topPaste]\n  }\n}; // Track characters inserted via keypress and composition events.\n\nvar fallbackChars = null; // Track whether we've ever handled a keypress on the space key.\n\nvar hasSpaceKeypress = false;\n/**\n * Return whether a native keypress event is assumed to be a command.\n * This is required because Firefox fires `keypress` events for key commands\n * (cut, copy, select-all, etc.) even though no character is inserted.\n */\n\nfunction isKeypressCommand(nativeEvent) {\n  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.\n  !(nativeEvent.ctrlKey && nativeEvent.altKey);\n}\n/**\n * Create an `onBeforeInput` event to match\n * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.\n *\n * This event plugin is based on the native `textInput` event\n * available in Chrome, Safari, Opera, and IE. This event fires after\n * `onKeyPress` and `onCompositionEnd`, but before `onInput`.\n *\n * `beforeInput` is spec'd but not implemented in any browsers, and\n * the `input` event does not provide any useful information about what has\n * actually been added, contrary to the spec. Thus, `textInput` is the best\n * available event to identify the characters that have actually been inserted\n * into the target node.\n */\n\n\nvar BeforeInputEventPlugin = {\n  eventTypes: eventTypes,\n\n  /**\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {DOMEventTarget} topLevelTarget The listening component root node.\n   * @param {string} topLevelTargetID ID of `topLevelTarget`.\n   * @param {object} nativeEvent Native browser event.\n   * @return {*} An accumulation of synthetic events.\n   * @see {EventPluginHub.extractEvents}\n   */\n  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {\n    var chars;\n\n    if (canUseTextInputEvent) {\n      switch (topLevelType) {\n        case topLevelTypes.topKeyPress:\n          /**\n           * If native `textInput` events are available, our goal is to make\n           * use of them. However, there is a special case: the spacebar key.\n           * In Webkit, preventing default on a spacebar `textInput` event\n           * cancels character insertion, but it *also* causes the browser\n           * to fall back to its default spacebar behavior of scrolling the\n           * page.\n           *\n           * Tracking at:\n           * https://code.google.com/p/chromium/issues/detail?id=355103\n           *\n           * To avoid this issue, use the keypress event as if no `textInput`\n           * event is available.\n           */\n          var which = nativeEvent.which;\n\n          if (which !== SPACEBAR_CODE) {\n            return;\n          }\n\n          hasSpaceKeypress = true;\n          chars = SPACEBAR_CHAR;\n          break;\n\n        case topLevelTypes.topTextInput:\n          // Record the characters to be added to the DOM.\n          chars = nativeEvent.data; // If it's a spacebar character, assume that we have already handled\n          // it at the keypress level and bail immediately. Android Chrome\n          // doesn't give us keycodes, so we need to blacklist it.\n\n          if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {\n            return;\n          } // Otherwise, carry on.\n\n\n          break;\n\n        default:\n          // For other native event types, do nothing.\n          return;\n      }\n    } else {\n      switch (topLevelType) {\n        case topLevelTypes.topPaste:\n          // If a paste event occurs after a keypress, throw out the input\n          // chars. Paste events should not lead to BeforeInput events.\n          fallbackChars = null;\n          break;\n\n        case topLevelTypes.topKeyPress:\n          /**\n           * As of v27, Firefox may fire keypress events even when no character\n           * will be inserted. A few possibilities:\n           *\n           * - `which` is `0`. Arrow keys, Esc key, etc.\n           *\n           * - `which` is the pressed key code, but no char is available.\n           *   Ex: 'AltGr + d` in Polish. There is no modified character for\n           *   this key combination and no character is inserted into the\n           *   document, but FF fires the keypress for char code `100` anyway.\n           *   No `input` event will occur.\n           *\n           * - `which` is the pressed key code, but a command combination is\n           *   being used. Ex: `Cmd+C`. No character is inserted, and no\n           *   `input` event will occur.\n           */\n          if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {\n            fallbackChars = String.fromCharCode(nativeEvent.which);\n          }\n\n          break;\n\n        case topLevelTypes.topCompositionEnd:\n          fallbackChars = nativeEvent.data;\n          break;\n      } // If no changes have occurred to the fallback string, no relevant\n      // event has fired and we're done.\n\n\n      if (fallbackChars === null) {\n        return;\n      }\n\n      chars = fallbackChars;\n    } // If no characters are being inserted, no BeforeInput event should\n    // be fired.\n\n\n    if (!chars) {\n      return;\n    }\n\n    var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, topLevelTargetID, nativeEvent);\n    event.data = chars;\n    fallbackChars = null;\n    EventPropagators.accumulateTwoPhaseDispatches(event);\n    return event;\n  }\n};\nmodule.exports = BeforeInputEventPlugin;","map":{"version":3,"sources":["/Users/ejmaltes/Desktop/Personal-Website/node_modules/react-object-fit-cover/node_modules/react/lib/BeforeInputEventPlugin.js"],"names":["EventConstants","require","EventPropagators","ExecutionEnvironment","SyntheticInputEvent","keyOf","canUseTextInputEvent","canUseDOM","window","document","isPresto","opera","version","parseInt","SPACEBAR_CODE","SPACEBAR_CHAR","String","fromCharCode","topLevelTypes","eventTypes","beforeInput","phasedRegistrationNames","bubbled","onBeforeInput","captured","onBeforeInputCapture","dependencies","topCompositionEnd","topKeyPress","topTextInput","topPaste","fallbackChars","hasSpaceKeypress","isKeypressCommand","nativeEvent","ctrlKey","altKey","metaKey","BeforeInputEventPlugin","extractEvents","topLevelType","topLevelTarget","topLevelTargetID","chars","which","data","event","getPooled","accumulateTwoPhaseDispatches","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright 2013 Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule BeforeInputEventPlugin\n * @typechecks static-only\n */\n\n\"use strict\";\n\nvar EventConstants = require(\"./EventConstants\");\nvar EventPropagators = require(\"./EventPropagators\");\nvar ExecutionEnvironment = require(\"./ExecutionEnvironment\");\nvar SyntheticInputEvent = require(\"./SyntheticInputEvent\");\n\nvar keyOf = require(\"./keyOf\");\n\nvar canUseTextInputEvent = (\n  ExecutionEnvironment.canUseDOM &&\n  'TextEvent' in window &&\n  !('documentMode' in document || isPresto())\n);\n\n/**\n * Opera <= 12 includes TextEvent in window, but does not fire\n * text input events. Rely on keypress instead.\n */\nfunction isPresto() {\n  var opera = window.opera;\n  return (\n    typeof opera === 'object' &&\n    typeof opera.version === 'function' &&\n    parseInt(opera.version(), 10) <= 12\n  );\n}\n\nvar SPACEBAR_CODE = 32;\nvar SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);\n\nvar topLevelTypes = EventConstants.topLevelTypes;\n\n// Events and their corresponding property names.\nvar eventTypes = {\n  beforeInput: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onBeforeInput: null}),\n      captured: keyOf({onBeforeInputCapture: null})\n    },\n    dependencies: [\n      topLevelTypes.topCompositionEnd,\n      topLevelTypes.topKeyPress,\n      topLevelTypes.topTextInput,\n      topLevelTypes.topPaste\n    ]\n  }\n};\n\n// Track characters inserted via keypress and composition events.\nvar fallbackChars = null;\n\n// Track whether we've ever handled a keypress on the space key.\nvar hasSpaceKeypress = false;\n\n/**\n * Return whether a native keypress event is assumed to be a command.\n * This is required because Firefox fires `keypress` events for key commands\n * (cut, copy, select-all, etc.) even though no character is inserted.\n */\nfunction isKeypressCommand(nativeEvent) {\n  return (\n    (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&\n    // ctrlKey && altKey is equivalent to AltGr, and is not a command.\n    !(nativeEvent.ctrlKey && nativeEvent.altKey)\n  );\n}\n\n/**\n * Create an `onBeforeInput` event to match\n * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.\n *\n * This event plugin is based on the native `textInput` event\n * available in Chrome, Safari, Opera, and IE. This event fires after\n * `onKeyPress` and `onCompositionEnd`, but before `onInput`.\n *\n * `beforeInput` is spec'd but not implemented in any browsers, and\n * the `input` event does not provide any useful information about what has\n * actually been added, contrary to the spec. Thus, `textInput` is the best\n * available event to identify the characters that have actually been inserted\n * into the target node.\n */\nvar BeforeInputEventPlugin = {\n\n  eventTypes: eventTypes,\n\n  /**\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {DOMEventTarget} topLevelTarget The listening component root node.\n   * @param {string} topLevelTargetID ID of `topLevelTarget`.\n   * @param {object} nativeEvent Native browser event.\n   * @return {*} An accumulation of synthetic events.\n   * @see {EventPluginHub.extractEvents}\n   */\n  extractEvents: function(\n      topLevelType,\n      topLevelTarget,\n      topLevelTargetID,\n      nativeEvent) {\n\n    var chars;\n\n    if (canUseTextInputEvent) {\n      switch (topLevelType) {\n        case topLevelTypes.topKeyPress:\n          /**\n           * If native `textInput` events are available, our goal is to make\n           * use of them. However, there is a special case: the spacebar key.\n           * In Webkit, preventing default on a spacebar `textInput` event\n           * cancels character insertion, but it *also* causes the browser\n           * to fall back to its default spacebar behavior of scrolling the\n           * page.\n           *\n           * Tracking at:\n           * https://code.google.com/p/chromium/issues/detail?id=355103\n           *\n           * To avoid this issue, use the keypress event as if no `textInput`\n           * event is available.\n           */\n          var which = nativeEvent.which;\n          if (which !== SPACEBAR_CODE) {\n            return;\n          }\n\n          hasSpaceKeypress = true;\n          chars = SPACEBAR_CHAR;\n          break;\n\n        case topLevelTypes.topTextInput:\n          // Record the characters to be added to the DOM.\n          chars = nativeEvent.data;\n\n          // If it's a spacebar character, assume that we have already handled\n          // it at the keypress level and bail immediately. Android Chrome\n          // doesn't give us keycodes, so we need to blacklist it.\n          if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {\n            return;\n          }\n\n          // Otherwise, carry on.\n          break;\n\n        default:\n          // For other native event types, do nothing.\n          return;\n      }\n    } else {\n      switch (topLevelType) {\n        case topLevelTypes.topPaste:\n          // If a paste event occurs after a keypress, throw out the input\n          // chars. Paste events should not lead to BeforeInput events.\n          fallbackChars = null;\n          break;\n        case topLevelTypes.topKeyPress:\n          /**\n           * As of v27, Firefox may fire keypress events even when no character\n           * will be inserted. A few possibilities:\n           *\n           * - `which` is `0`. Arrow keys, Esc key, etc.\n           *\n           * - `which` is the pressed key code, but no char is available.\n           *   Ex: 'AltGr + d` in Polish. There is no modified character for\n           *   this key combination and no character is inserted into the\n           *   document, but FF fires the keypress for char code `100` anyway.\n           *   No `input` event will occur.\n           *\n           * - `which` is the pressed key code, but a command combination is\n           *   being used. Ex: `Cmd+C`. No character is inserted, and no\n           *   `input` event will occur.\n           */\n          if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {\n            fallbackChars = String.fromCharCode(nativeEvent.which);\n          }\n          break;\n        case topLevelTypes.topCompositionEnd:\n          fallbackChars = nativeEvent.data;\n          break;\n      }\n\n      // If no changes have occurred to the fallback string, no relevant\n      // event has fired and we're done.\n      if (fallbackChars === null) {\n        return;\n      }\n\n      chars = fallbackChars;\n    }\n\n    // If no characters are being inserted, no BeforeInput event should\n    // be fired.\n    if (!chars) {\n      return;\n    }\n\n    var event = SyntheticInputEvent.getPooled(\n      eventTypes.beforeInput,\n      topLevelTargetID,\n      nativeEvent\n    );\n\n    event.data = chars;\n    fallbackChars = null;\n    EventPropagators.accumulateTwoPhaseDispatches(event);\n    return event;\n  }\n};\n\nmodule.exports = BeforeInputEventPlugin;\n"]},"metadata":{},"sourceType":"script"}