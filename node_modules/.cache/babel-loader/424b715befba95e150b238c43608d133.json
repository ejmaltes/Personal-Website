{"ast":null,"code":"/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @typechecks static-only\n * @providesModule ReactTransitionChildMapping\n */\n\"use strict\";\n\nvar ReactChildren = require(\"./ReactChildren\");\n\nvar ReactTransitionChildMapping = {\n  /**\n   * Given `this.props.children`, return an object mapping key to child. Just\n   * simple syntactic sugar around ReactChildren.map().\n   *\n   * @param {*} children `this.props.children`\n   * @return {object} Mapping of key to child\n   */\n  getChildMapping: function (children) {\n    return ReactChildren.map(children, function (child) {\n      return child;\n    });\n  },\n\n  /**\n   * When you're adding or removing children some may be added or removed in the\n   * same render pass. We want to show *both* since we want to simultaneously\n   * animate elements in and out. This function takes a previous set of keys\n   * and a new set of keys and merges them with its best guess of the correct\n   * ordering. In the future we may expose some of the utilities in\n   * ReactMultiChild to make this easy, but for now React itself does not\n   * directly have this concept of the union of prevChildren and nextChildren\n   * so we implement it here.\n   *\n   * @param {object} prev prev children as returned from\n   * `ReactTransitionChildMapping.getChildMapping()`.\n   * @param {object} next next children as returned from\n   * `ReactTransitionChildMapping.getChildMapping()`.\n   * @return {object} a key set that contains all keys in `prev` and all keys\n   * in `next` in a reasonable order.\n   */\n  mergeChildMappings: function (prev, next) {\n    prev = prev || {};\n    next = next || {};\n\n    function getValueForKey(key) {\n      if (next.hasOwnProperty(key)) {\n        return next[key];\n      } else {\n        return prev[key];\n      }\n    } // For each key of `next`, the list of keys to insert before that key in\n    // the combined list\n\n\n    var nextKeysPending = {};\n    var pendingKeys = [];\n\n    for (var prevKey in prev) {\n      if (next.hasOwnProperty(prevKey)) {\n        if (pendingKeys.length) {\n          nextKeysPending[prevKey] = pendingKeys;\n          pendingKeys = [];\n        }\n      } else {\n        pendingKeys.push(prevKey);\n      }\n    }\n\n    var i;\n    var childMapping = {};\n\n    for (var nextKey in next) {\n      if (nextKeysPending.hasOwnProperty(nextKey)) {\n        for (i = 0; i < nextKeysPending[nextKey].length; i++) {\n          var pendingNextKey = nextKeysPending[nextKey][i];\n          childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);\n        }\n      }\n\n      childMapping[nextKey] = getValueForKey(nextKey);\n    } // Finally, add the keys which didn't appear before any key in `next`\n\n\n    for (i = 0; i < pendingKeys.length; i++) {\n      childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);\n    }\n\n    return childMapping;\n  }\n};\nmodule.exports = ReactTransitionChildMapping;","map":{"version":3,"sources":["/Users/ejmaltes/Desktop/Personal-Website/node_modules/react-object-fit-cover/node_modules/react/lib/ReactTransitionChildMapping.js"],"names":["ReactChildren","require","ReactTransitionChildMapping","getChildMapping","children","map","child","mergeChildMappings","prev","next","getValueForKey","key","hasOwnProperty","nextKeysPending","pendingKeys","prevKey","length","push","i","childMapping","nextKey","pendingNextKey","module","exports"],"mappings":"AAAA;;;;;;;;;;;AAYA;;AAEA,IAAIA,aAAa,GAAGC,OAAO,CAAC,iBAAD,CAA3B;;AAEA,IAAIC,2BAA2B,GAAG;AAChC;;;;;;;AAOAC,EAAAA,eAAe,EAAE,UAASC,QAAT,EAAmB;AAClC,WAAOJ,aAAa,CAACK,GAAd,CAAkBD,QAAlB,EAA4B,UAASE,KAAT,EAAgB;AACjD,aAAOA,KAAP;AACD,KAFM,CAAP;AAGD,GAZ+B;;AAchC;;;;;;;;;;;;;;;;;AAiBAC,EAAAA,kBAAkB,EAAE,UAASC,IAAT,EAAeC,IAAf,EAAqB;AACvCD,IAAAA,IAAI,GAAGA,IAAI,IAAI,EAAf;AACAC,IAAAA,IAAI,GAAGA,IAAI,IAAI,EAAf;;AAEA,aAASC,cAAT,CAAwBC,GAAxB,EAA6B;AAC3B,UAAIF,IAAI,CAACG,cAAL,CAAoBD,GAApB,CAAJ,EAA8B;AAC5B,eAAOF,IAAI,CAACE,GAAD,CAAX;AACD,OAFD,MAEO;AACL,eAAOH,IAAI,CAACG,GAAD,CAAX;AACD;AACF,KAVsC,CAYvC;AACA;;;AACA,QAAIE,eAAe,GAAG,EAAtB;AAEA,QAAIC,WAAW,GAAG,EAAlB;;AACA,SAAK,IAAIC,OAAT,IAAoBP,IAApB,EAA0B;AACxB,UAAIC,IAAI,CAACG,cAAL,CAAoBG,OAApB,CAAJ,EAAkC;AAChC,YAAID,WAAW,CAACE,MAAhB,EAAwB;AACtBH,UAAAA,eAAe,CAACE,OAAD,CAAf,GAA2BD,WAA3B;AACAA,UAAAA,WAAW,GAAG,EAAd;AACD;AACF,OALD,MAKO;AACLA,QAAAA,WAAW,CAACG,IAAZ,CAAiBF,OAAjB;AACD;AACF;;AAED,QAAIG,CAAJ;AACA,QAAIC,YAAY,GAAG,EAAnB;;AACA,SAAK,IAAIC,OAAT,IAAoBX,IAApB,EAA0B;AACxB,UAAII,eAAe,CAACD,cAAhB,CAA+BQ,OAA/B,CAAJ,EAA6C;AAC3C,aAAKF,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGL,eAAe,CAACO,OAAD,CAAf,CAAyBJ,MAAzC,EAAiDE,CAAC,EAAlD,EAAsD;AACpD,cAAIG,cAAc,GAAGR,eAAe,CAACO,OAAD,CAAf,CAAyBF,CAAzB,CAArB;AACAC,UAAAA,YAAY,CAACN,eAAe,CAACO,OAAD,CAAf,CAAyBF,CAAzB,CAAD,CAAZ,GAA4CR,cAAc,CACxDW,cADwD,CAA1D;AAGD;AACF;;AACDF,MAAAA,YAAY,CAACC,OAAD,CAAZ,GAAwBV,cAAc,CAACU,OAAD,CAAtC;AACD,KAxCsC,CA0CvC;;;AACA,SAAKF,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGJ,WAAW,CAACE,MAA5B,EAAoCE,CAAC,EAArC,EAAyC;AACvCC,MAAAA,YAAY,CAACL,WAAW,CAACI,CAAD,CAAZ,CAAZ,GAA+BR,cAAc,CAACI,WAAW,CAACI,CAAD,CAAZ,CAA7C;AACD;;AAED,WAAOC,YAAP;AACD;AA/E+B,CAAlC;AAkFAG,MAAM,CAACC,OAAP,GAAiBrB,2BAAjB","sourcesContent":["/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @typechecks static-only\n * @providesModule ReactTransitionChildMapping\n */\n\n\"use strict\";\n\nvar ReactChildren = require(\"./ReactChildren\");\n\nvar ReactTransitionChildMapping = {\n  /**\n   * Given `this.props.children`, return an object mapping key to child. Just\n   * simple syntactic sugar around ReactChildren.map().\n   *\n   * @param {*} children `this.props.children`\n   * @return {object} Mapping of key to child\n   */\n  getChildMapping: function(children) {\n    return ReactChildren.map(children, function(child) {\n      return child;\n    });\n  },\n\n  /**\n   * When you're adding or removing children some may be added or removed in the\n   * same render pass. We want to show *both* since we want to simultaneously\n   * animate elements in and out. This function takes a previous set of keys\n   * and a new set of keys and merges them with its best guess of the correct\n   * ordering. In the future we may expose some of the utilities in\n   * ReactMultiChild to make this easy, but for now React itself does not\n   * directly have this concept of the union of prevChildren and nextChildren\n   * so we implement it here.\n   *\n   * @param {object} prev prev children as returned from\n   * `ReactTransitionChildMapping.getChildMapping()`.\n   * @param {object} next next children as returned from\n   * `ReactTransitionChildMapping.getChildMapping()`.\n   * @return {object} a key set that contains all keys in `prev` and all keys\n   * in `next` in a reasonable order.\n   */\n  mergeChildMappings: function(prev, next) {\n    prev = prev || {};\n    next = next || {};\n\n    function getValueForKey(key) {\n      if (next.hasOwnProperty(key)) {\n        return next[key];\n      } else {\n        return prev[key];\n      }\n    }\n\n    // For each key of `next`, the list of keys to insert before that key in\n    // the combined list\n    var nextKeysPending = {};\n\n    var pendingKeys = [];\n    for (var prevKey in prev) {\n      if (next.hasOwnProperty(prevKey)) {\n        if (pendingKeys.length) {\n          nextKeysPending[prevKey] = pendingKeys;\n          pendingKeys = [];\n        }\n      } else {\n        pendingKeys.push(prevKey);\n      }\n    }\n\n    var i;\n    var childMapping = {};\n    for (var nextKey in next) {\n      if (nextKeysPending.hasOwnProperty(nextKey)) {\n        for (i = 0; i < nextKeysPending[nextKey].length; i++) {\n          var pendingNextKey = nextKeysPending[nextKey][i];\n          childMapping[nextKeysPending[nextKey][i]] = getValueForKey(\n            pendingNextKey\n          );\n        }\n      }\n      childMapping[nextKey] = getValueForKey(nextKey);\n    }\n\n    // Finally, add the keys which didn't appear before any key in `next`\n    for (i = 0; i < pendingKeys.length; i++) {\n      childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);\n    }\n\n    return childMapping;\n  }\n};\n\nmodule.exports = ReactTransitionChildMapping;\n"]},"metadata":{},"sourceType":"script"}